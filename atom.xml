<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>事了拂身去 深藏功与名</title>
  
  <subtitle>[object Object]</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhsongdanc.github.io/"/>
  <updated>2025-11-21T09:51:27.911Z</updated>
  <id>https://zhsongdanc.github.io/</id>
  
  <author>
    <name>zhsong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HikariCP 连接池详解</title>
    <link href="https://zhsongdanc.github.io/posts/101.html"/>
    <id>https://zhsongdanc.github.io/posts/101.html</id>
    <published>2025-10-08T02:30:07.000Z</published>
    <updated>2025-11-21T09:51:27.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HikariCP-连接池详解"><a href="#HikariCP-连接池详解" class="headerlink" title="HikariCP 连接池详解"></a>HikariCP 连接池详解</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#核心概念">核心概念</a></li><li><a href="#连接获取流程">连接获取流程</a></li><li><a href="#连接归还流程">连接归还流程</a></li><li><a href="#concurrentbag-三层查找机制">ConcurrentBag 三层查找机制</a></li><li><a href="#关键组件详解">关键组件详解</a></li><li><a href="#常见问题解答">常见问题解答</a></li><li><a href="#设计决策分析">设计决策分析</a></li></ol><hr><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="1-基本组件"><a href="#1-基本组件" class="headerlink" title="1. 基本组件"></a>1. 基本组件</h3><h4 id="Connection（真实连接）"><a href="#Connection（真实连接）" class="headerlink" title="Connection（真实连接）"></a>Connection（真实连接）</h4><ul><li>数据库驱动提供的真实 JDBC 连接</li><li>例如 MySQL 的 <code>com.mysql.cj.jdbc.ConnectionImpl</code></li><li>直接与数据库通信</li></ul><h4 id="PoolEntry（连接条目）"><a href="#PoolEntry（连接条目）" class="headerlink" title="PoolEntry（连接条目）"></a>PoolEntry（连接条目）</h4><ul><li>连接池内部用来管理连接的包装类</li><li>每个 <code>PoolEntry</code> 唯一对应一个真实的 <code>Connection</code></li><li>包含连接的状态、时间戳等信息</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PoolEntry</span> <span class="token keyword">implements</span> <span class="token class-name">IConcurrentBagEntry</span> <span class="token punctuation">{</span>    Connection connection<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 真实连接</span>    <span class="token keyword">long</span> lastAccessed<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 最后访问时间</span>    <span class="token keyword">long</span> lastBorrowed<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 最后借出时间</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 状态（空闲/使用中/已移除等）</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否被标记驱逐</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ProxyConnection（代理连接）"><a href="#ProxyConnection（代理连接）" class="headerlink" title="ProxyConnection（代理连接）"></a>ProxyConnection（代理连接）</h4><ul><li>应用层拿到的连接对象</li><li>内部持有 <code>PoolEntry</code> 和真实 <code>Connection</code></li><li>拦截 <code>close()</code> 等方法，将连接归还池中而不是真正关闭</li></ul><h4 id="ConcurrentBag（连接袋）"><a href="#ConcurrentBag（连接袋）" class="headerlink" title="ConcurrentBag（连接袋）"></a>ConcurrentBag（连接袋）</h4><ul><li>存放 <code>PoolEntry</code> 的容器</li><li>提供 <code>borrow()</code> 和 <code>requite()</code> 方法</li><li>使用线程本地缓存和共享列表，减少锁竞争</li></ul><h4 id="bagEntry"><a href="#bagEntry" class="headerlink" title="bagEntry"></a>bagEntry</h4><ul><li><code>bagEntry</code> 就是 <code>PoolEntry</code></li><li>在 <code>ConcurrentBag</code> 的方法里，参数名用 <code>bagEntry</code> 表示”袋子里的条目”</li></ul><h3 id="2-关系图"><a href="#2-关系图" class="headerlink" title="2. 关系图"></a>2. 关系图</h3><pre><code>应用代码   ↓ 调用 getConnection()HikariPool   ↓ 从 ConcurrentBag 借出PoolEntry (bagEntry)   ↓ 包装成ProxyConnection   ↓ 返回给应用应用拿到 ProxyConnection，但实际使用的是 PoolEntry 里的真实 Connection</code></pre><hr><h2 id="连接获取流程"><a href="#连接获取流程" class="headerlink" title="连接获取流程"></a>连接获取流程</h2><h3 id="1-入口方法"><a href="#1-入口方法" class="headerlink" title="1. 入口方法"></a>1. 入口方法</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Connection <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">long</span> hardTimeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    suspendResumeLock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> timeout <span class="token operator">=</span> hardTimeout<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从 ConcurrentBag 借出 PoolEntry</span>            PoolEntry poolEntry <span class="token operator">=</span> connectionBag<span class="token punctuation">.</span><span class="token function">borrow</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>poolEntry <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 超时</span>            <span class="token punctuation">}</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 健康检查</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>poolEntry<span class="token punctuation">.</span><span class="token function">isMarkedEvicted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>                 <span class="token punctuation">(</span><span class="token function">elapsedMillis</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">.</span>lastAccessed<span class="token punctuation">,</span> now<span class="token punctuation">)</span> <span class="token operator">></span> aliveBypassWindowMs                  <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isConnectionAlive</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">.</span>connection<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 连接不可用，关闭并重试</span>                <span class="token function">closeConnection</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                timeout <span class="token operator">=</span> hardTimeout <span class="token operator">-</span> <span class="token function">elapsedMillis</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 连接可用，创建代理连接返回</span>                metricsTracker<span class="token punctuation">.</span><span class="token function">recordBorrowStats</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">,</span> startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> poolEntry<span class="token punctuation">.</span><span class="token function">createProxyConnection</span><span class="token punctuation">(</span>                    leakTaskFactory<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>timeout <span class="token operator">></span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 超时，抛出异常</span>        metricsTracker<span class="token punctuation">.</span><span class="token function">recordBorrowTimeoutStats</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> <span class="token function">createTimeoutException</span><span class="token punctuation">(</span>startTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        suspendResumeLock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-关键步骤"><a href="#2-关键步骤" class="headerlink" title="2. 关键步骤"></a>2. 关键步骤</h3><ol><li><strong>获取 suspendResumeLock</strong>：确保池未被挂起</li><li><strong>从 ConcurrentBag 借出</strong>：三层查找机制（见下文）</li><li><strong>健康检查</strong>：<ul><li>检查是否被标记驱逐</li><li>检查连接是否存活（超过 <code>aliveBypassWindowMs</code> 需要检测）</li></ul></li><li><strong>创建代理连接</strong>：包装成 <code>ProxyConnection</code> 并启动泄漏检测</li><li><strong>返回给应用</strong>：应用获得代理连接</li></ol><hr><h2 id="连接归还流程"><a href="#连接归还流程" class="headerlink" title="连接归还流程"></a>连接归还流程</h2><h3 id="1-应用调用-close"><a href="#1-应用调用-close" class="headerlink" title="1. 应用调用 close()"></a>1. 应用调用 close()</h3><pre class="line-numbers language-java"><code class="language-java">connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 应用代码</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-ProxyConnection-拦截-close"><a href="#2-ProxyConnection-拦截-close" class="headerlink" title="2. ProxyConnection 拦截 close()"></a>2. ProxyConnection 拦截 close()</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. 关闭所有 Statement</span>    <span class="token function">closeStatements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>delegate <span class="token operator">!=</span> ClosedConnection<span class="token punctuation">.</span>CLOSED_CONNECTION<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 2. 取消泄漏检测任务</span>        leakTask<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 3. 清理连接状态</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>isCommitStateDirty <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isAutoCommit<span class="token punctuation">)</span> <span class="token punctuation">{</span>                delegate<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>dirtyBits <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                poolEntry<span class="token punctuation">.</span><span class="token function">resetConnectionState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> dirtyBits<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            delegate<span class="token punctuation">.</span><span class="token function">clearWarnings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>poolEntry<span class="token punctuation">.</span><span class="token function">isMarkedEvicted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token function">checkException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 4. 归还连接</span>            delegate <span class="token operator">=</span> ClosedConnection<span class="token punctuation">.</span>CLOSED_CONNECTION<span class="token punctuation">;</span>            poolEntry<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span>lastAccess<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-调用链"><a href="#3-调用链" class="headerlink" title="3. 调用链"></a>3. 调用链</h3><pre><code>ProxyConnection.close()    ↓ 调用 poolEntry.recycle(lastAccess)PoolEntry.recycle()    ↓ 调用 hikariPool.recycle(this)HikariPool.recycle()    ↓ 调用 connectionBag.requite(poolEntry)ConcurrentBag.requite()    ↓ 执行 threadLocalList.add(bagEntry) 或放入 handoffQueue连接被归还到池中 ✓</code></pre><h3 id="4-requite-方法详解"><a href="#4-requite-方法详解" class="headerlink" title="4. requite() 方法详解"></a>4. requite() 方法详解</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">requite</span><span class="token punctuation">(</span><span class="token keyword">final</span> T bagEntry<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 1. 设置状态为空闲</span>    bagEntry<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>STATE_NOT_IN_USE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2. 如果有等待线程，优先放入 handoffQueue 直接交付</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> waiters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> STATE_NOT_IN_USE <span class="token operator">||</span>             handoffQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>bagEntry<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重试逻辑...</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 3. 否则放入线程本地列表（最多50个）</span>    <span class="token keyword">final</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> threadLocalList <span class="token operator">=</span> threadList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>threadLocalList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        threadLocalList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>weakThreadLocals <span class="token operator">?</span>             <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>bagEntry<span class="token punctuation">)</span> <span class="token operator">:</span> bagEntry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="ConcurrentBag-三层查找机制"><a href="#ConcurrentBag-三层查找机制" class="headerlink" title="ConcurrentBag 三层查找机制"></a>ConcurrentBag 三层查找机制</h2><h3 id="第一层：线程本地列表（threadList）"><a href="#第一层：线程本地列表（threadList）" class="headerlink" title="第一层：线程本地列表（threadList）"></a>第一层：线程本地列表（threadList）</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Try the thread-local list first</span><span class="token keyword">final</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> list <span class="token operator">=</span> threadList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> Object entry <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> T bagEntry <span class="token operator">=</span> weakThreadLocals <span class="token operator">?</span>         <span class="token punctuation">(</span><span class="token punctuation">(</span>WeakReference<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> entry<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> entry<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>         bagEntry<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>STATE_NOT_IN_USE<span class="token punctuation">,</span> STATE_IN_USE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> bagEntry<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>ThreadLocal 存储</strong>：每个线程有独立的列表，互不干扰</li><li><strong>从后往前遍历</strong>：优先取最近归还的连接</li><li><strong>CAS 状态切换</strong>：使用 <code>compareAndSet</code> 原子操作</li><li><strong>无锁设计</strong>：线程只访问自己的列表，无需同步</li></ul><h4 id="为什么优先使用？"><a href="#为什么优先使用？" class="headerlink" title="为什么优先使用？"></a>为什么优先使用？</h4><ul><li>✅ 无锁：线程只访问自己的列表，无需同步</li><li>✅ 缓存局部性：CPU 缓存命中率高</li><li>✅ 减少竞争：避免多线程争用共享资源</li></ul><h4 id="为什么是-List-而不是单个连接？"><a href="#为什么是-List-而不是单个连接？" class="headerlink" title="为什么是 List 而不是单个连接？"></a>为什么是 List 而不是单个连接？</h4><p>虽然大多数情况下线程只需要一个连接，但：</p><ol><li><strong>连接复用缓存</strong>：归还后可能很快又要用，缓存起来快速获取</li><li><strong>支持嵌套场景</strong>：一个线程可能需要多个连接（嵌套事务、并行查询）</li><li><strong>限制在50个</strong>：防止无限增长</li></ol><h3 id="第二层：共享列表（sharedList）"><a href="#第二层：共享列表（sharedList）" class="headerlink" title="第二层：共享列表（sharedList）"></a>第二层：共享列表（sharedList）</h3><h4 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Otherwise, scan the shared list</span><span class="token keyword">final</span> <span class="token keyword">int</span> waiting <span class="token operator">=</span> waiters<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>T bagEntry <span class="token operator">:</span> sharedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>STATE_NOT_IN_USE<span class="token punctuation">,</span> STATE_IN_USE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果等待线程数 > 1，触发补偿创建</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>waiting <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                listener<span class="token punctuation">.</span><span class="token function">addBagItem</span><span class="token punctuation">(</span>waiting <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> bagEntry<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没有可用连接，触发创建新连接</span>    listener<span class="token punctuation">.</span><span class="token function">addBagItem</span><span class="token punctuation">(</span>waiting<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    waiters<span class="token punctuation">.</span><span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>共享资源</strong>：所有线程共享的 <code>CopyOnWriteArrayList</code></li><li><strong>线性扫描</strong>：遍历查找空闲连接</li><li><strong>CAS 竞争</strong>：多个线程可能同时尝试获取同一连接</li><li><strong>补偿机制</strong>：如果等待线程数 &gt; 1，触发创建新连接</li></ul><h4 id="关键变量"><a href="#关键变量" class="headerlink" title="关键变量"></a>关键变量</h4><ul><li><strong>sharedList</strong>：存储所有连接的全局列表</li><li><strong>waiters</strong>：统计当前等待连接的线程数</li><li><strong>listener</strong>：回调接口，当需要创建新连接时通知外部</li></ul><h3 id="第三层：等待队列（handoffQueue）"><a href="#第三层：等待队列（handoffQueue）" class="headerlink" title="第三层：等待队列（handoffQueue）"></a>第三层：等待队列（handoffQueue）</h3><h4 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 阻塞等待新连接</span>timeout <span class="token operator">=</span> timeUnit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">do</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token function">currentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> T bagEntry <span class="token operator">=</span> handoffQueue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span>timeout<span class="token punctuation">,</span> NANOSECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>bagEntry <span class="token operator">==</span> null <span class="token operator">||</span>         bagEntry<span class="token punctuation">.</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>STATE_NOT_IN_USE<span class="token punctuation">,</span> STATE_IN_USE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> bagEntry<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    timeout <span class="token operator">-=</span> <span class="token function">elapsedNanos</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>timeout <span class="token operator">></span> 10_000<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>SynchronousQueue</strong>：无缓冲队列，生产者必须等待消费者</li><li><strong>阻塞等待</strong>：在超时内等待新连接</li><li><strong>直接交付</strong>：连接归还时如果有等待线程，直接放入队列</li></ul><h4 id="为什么需要？"><a href="#为什么需要？" class="headerlink" title="为什么需要？"></a>为什么需要？</h4><ul><li>当前无可用连接时，避免忙等待</li><li>连接归还时直接交付，减少唤醒延迟</li></ul><hr><h2 id="关键组件详解"><a href="#关键组件详解" class="headerlink" title="关键组件详解"></a>关键组件详解</h2><h3 id="1-aliveBypassWindowMs（健康检查窗口）"><a href="#1-aliveBypassWindowMs（健康检查窗口）" class="headerlink" title="1. aliveBypassWindowMs（健康检查窗口）"></a>1. aliveBypassWindowMs（健康检查窗口）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> aliveBypassWindowMs <span class="token operator">=</span> Long<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>    <span class="token string">"com.zaxxer.hikari.aliveBypassWindowMs"</span><span class="token punctuation">,</span>     MILLISECONDS<span class="token punctuation">.</span><span class="token function">toMillis</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>默认 500ms 的时间窗口</li><li>在这个窗口内再次借出同一连接时，可以跳过昂贵的 <code>isConnectionAlive</code> 检查</li><li>超过窗口时间，需要重新检测连接是否存活</li></ul><h4 id="判断逻辑"><a href="#判断逻辑" class="headerlink" title="判断逻辑"></a>判断逻辑</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">elapsedMillis</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">.</span>lastAccessed<span class="token punctuation">,</span> now<span class="token punctuation">)</span> <span class="token operator">></span> aliveBypassWindowMs     <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">isConnectionAlive</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">.</span>connection<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 连接可能已失效，关闭并重试</span>    <span class="token function">closeConnection</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">,</span> DEAD_CONNECTION_MESSAGE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-isMarkedEvicted-（驱逐标记）"><a href="#2-isMarkedEvicted-（驱逐标记）" class="headerlink" title="2. isMarkedEvicted()（驱逐标记）"></a>2. isMarkedEvicted()（驱逐标记）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">isMarkedEvicted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> evict<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">markEvicted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>evict <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li>标记连接需要被驱逐</li><li>当连接被标记后，下次借出时会立即关闭</li></ul><h4 id="连接被淘汰的原因"><a href="#连接被淘汰的原因" class="headerlink" title="连接被淘汰的原因"></a>连接被淘汰的原因</h4><ol><li><strong>生命周期到期</strong>：超过 <code>maxLifetime</code></li><li><strong>空闲超时</strong>：超过 <code>idleTimeout</code></li><li><strong>健康检查失败</strong>：连接已失效</li><li><strong>显式驱逐</strong>：调用 <code>softEvictConnections()</code></li><li><strong>异常状态</strong>：连接状态异常</li></ol><h3 id="3-ProxyConnection-创建机制"><a href="#3-ProxyConnection-创建机制" class="headerlink" title="3. ProxyConnection 创建机制"></a>3. ProxyConnection 创建机制</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">return</span> poolEntry<span class="token punctuation">.</span><span class="token function">createProxyConnection</span><span class="token punctuation">(</span>    leakTaskFactory<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>poolEntry<span class="token punctuation">)</span><span class="token punctuation">,</span> now<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li><strong>不创建新连接</strong>：<code>PoolEntry</code> 里已有真实连接</li><li><strong>创建代理对象</strong>：包装成 <code>ProxyConnection</code></li><li><strong>注册泄漏检测</strong>：启动定时任务监控连接是否泄漏</li></ol><h4 id="为什么需要代理？"><a href="#为什么需要代理？" class="headerlink" title="为什么需要代理？"></a>为什么需要代理？</h4><ul><li>拦截 <code>close()</code> 方法，归还到池中而不是真正关闭</li><li>跟踪 Statement，确保正确关闭</li><li>重置连接状态，保证连接可复用</li></ul><h3 id="4-泄漏检测机制"><a href="#4-泄漏检测机制" class="headerlink" title="4. 泄漏检测机制"></a>4. 泄漏检测机制</h3><h4 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>配置 <code>leakDetectionThreshold</code>（毫秒）</li><li>每次借出连接时启动 <code>ProxyLeakTask</code></li><li>如果在该时间内连接未归还，记录警告日志</li></ul><h4 id="如何定位问题？"><a href="#如何定位问题？" class="headerlink" title="如何定位问题？"></a>如何定位问题？</h4><ul><li>日志包含借出时的调用栈</li><li>通过堆栈信息定位哪段代码忘记 <code>close()</code></li></ul><h3 id="5-构建阶段代码生成"><a href="#5-构建阶段代码生成" class="headerlink" title="5. 构建阶段代码生成"></a>5. 构建阶段代码生成</h3><h4 id="为什么需要？-1"><a href="#为什么需要？-1" class="headerlink" title="为什么需要？"></a>为什么需要？</h4><ul><li><code>ProxyFactory</code> 源码中只有占位方法</li><li>真正的代理类在构建时由 <code>JavassistProxyFactory</code> 生成</li><li>生成专用的字节码代理，性能优于 JDK 动态代理</li></ul><h4 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h4><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.codehaus.mojo<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>exec-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>execution</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>phase</span><span class="token punctuation">></span></span>compile<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>phase</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goals</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>goal</span><span class="token punctuation">></span></span>exec<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goal</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>goals</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>execution</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executions</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>executable</span><span class="token punctuation">></span></span>java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>executable</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>arguments</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>argument</span><span class="token punctuation">></span></span>-cp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>argument</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>argument</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>argument</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>argument</span><span class="token punctuation">></span></span>com.zaxxer.hikari.util.JavassistProxyFactory<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>argument</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>arguments</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h2><h3 id="Q1-为什么线程本地列表是-List-而不是单个连接？"><a href="#Q1-为什么线程本地列表是-List-而不是单个连接？" class="headerlink" title="Q1: 为什么线程本地列表是 List 而不是单个连接？"></a>Q1: 为什么线程本地列表是 List 而不是单个连接？</h3><p><strong>A:</strong> 虽然大多数情况下线程只需要一个连接，但：</p><ol><li><strong>连接复用缓存</strong>：归还后可能很快又要用</li><li><strong>支持嵌套场景</strong>：一个线程可能需要多个连接</li><li><strong>限制在50个</strong>：防止无限增长</li></ol><p>实际运行中，线程本地列表通常只有 0-2 个连接。</p><h3 id="Q2-requite-怎么读？是什么意思？"><a href="#Q2-requite-怎么读？是什么意思？" class="headerlink" title="Q2: requite 怎么读？是什么意思？"></a>Q2: requite 怎么读？是什么意思？</h3><p><strong>A:</strong> </p><ul><li><strong>发音</strong>：/rɪˈkwaɪt/，中文近似音：<strong>瑞-快特</strong></li><li><strong>含义</strong>：报答、回报、归还</li><li><strong>在代码中</strong>：表示将连接归还到池中</li></ul><h3 id="Q3-listener、waiters、sharedList-分别是什么？"><a href="#Q3-listener、waiters、sharedList-分别是什么？" class="headerlink" title="Q3: listener、waiters、sharedList 分别是什么？"></a>Q3: listener、waiters、sharedList 分别是什么？</h3><p><strong>A:</strong></p><ul><li><strong>sharedList</strong>：存储所有连接的全局共享列表（<code>CopyOnWriteArrayList</code>）</li><li><strong>waiters</strong>：统计当前等待连接的线程数（<code>AtomicInteger</code>）</li><li><strong>listener</strong>：回调接口，当需要创建新连接时通知 <code>HikariPool</code></li></ul><h3 id="Q4-handoffQueue-是干什么的？"><a href="#Q4-handoffQueue-是干什么的？" class="headerlink" title="Q4: handoffQueue 是干什么的？"></a>Q4: handoffQueue 是干什么的？</h3><p><strong>A:</strong> </p><ul><li><strong>作用</strong>：直接交付连接给等待线程</li><li><strong>类型</strong>：<code>SynchronousQueue</code>（无缓冲队列）</li><li><strong>优势</strong>：避免等待线程被唤醒后还要扫描共享列表</li></ul><h3 id="Q5-为什么用-CopyOnWriteArrayList？"><a href="#Q5-为什么用-CopyOnWriteArrayList？" class="headerlink" title="Q5: 为什么用 CopyOnWriteArrayList？"></a>Q5: 为什么用 CopyOnWriteArrayList？</h3><p><strong>A:</strong></p><ul><li><strong>读多写少</strong>：连接池中遍历查找是高频操作</li><li><strong>读操作无锁</strong>：多线程并发读取性能好</li><li><strong>线程安全</strong>：无需额外同步</li><li><strong>避免异常</strong>：遍历时不会因并发修改而抛异常</li></ul><h3 id="Q6-为什么不使用读写锁或-Vector？"><a href="#Q6-为什么不使用读写锁或-Vector？" class="headerlink" title="Q6: 为什么不使用读写锁或 Vector？"></a>Q6: 为什么不使用读写锁或 Vector？</h3><p><strong>A:</strong></p><table><thead><tr><th>方案</th><th>问题</th></tr></thead><tbody><tr><td><strong>Vector</strong></td><td>所有操作都加锁，性能差</td></tr><tr><td><strong>ArrayList + synchronized</strong></td><td>读操作被写操作阻塞</td></tr><tr><td><strong>ReadWriteLock</strong></td><td>仍有锁开销，写操作会阻塞读操作</td></tr><tr><td><strong>CopyOnWriteArrayList</strong></td><td>✅ 读操作完全无锁，性能最优</td></tr></tbody></table><hr><h2 id="设计决策分析"><a href="#设计决策分析" class="headerlink" title="设计决策分析"></a>设计决策分析</h2><h3 id="CopyOnWriteArrayList-vs-ReadWriteLock"><a href="#CopyOnWriteArrayList-vs-ReadWriteLock" class="headerlink" title="CopyOnWriteArrayList vs ReadWriteLock"></a>CopyOnWriteArrayList vs ReadWriteLock</h3><h4 id="CopyOnWriteArrayList-的优势"><a href="#CopyOnWriteArrayList-的优势" class="headerlink" title="CopyOnWriteArrayList 的优势"></a>CopyOnWriteArrayList 的优势</h4><ol><li>✅ <strong>读操作完全无锁</strong>，性能最优</li><li>✅ <strong>读操作不会被写操作阻塞</strong></li><li>✅ <strong>实现简单</strong>，无死锁风险</li><li>✅ <strong>适合读多写少的场景</strong></li></ol><h4 id="ReadWriteLock-的优势"><a href="#ReadWriteLock-的优势" class="headerlink" title="ReadWriteLock 的优势"></a>ReadWriteLock 的优势</h4><ol><li>✅ <strong>数据实时性好</strong>（不是快照）</li><li>✅ <strong>写操作性能更好</strong>（不复制数组）</li><li>✅ <strong>内存占用更少</strong></li><li>✅ <strong>适合读写均衡或写多读少的场景</strong></li></ol><h4 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h4><ul><li><strong>读多写少</strong> → CopyOnWriteArrayList（如连接池）✓</li><li><strong>读写均衡</strong> → ReadWriteLock</li><li><strong>写多读少</strong> → ReadWriteLock</li><li><strong>需要实时数据</strong> → ReadWriteLock</li><li><strong>需要最高读性能</strong> → CopyOnWriteArrayList</li></ul><h3 id="为什么选择三层查找机制？"><a href="#为什么选择三层查找机制？" class="headerlink" title="为什么选择三层查找机制？"></a>为什么选择三层查找机制？</h3><h4 id="设计优势"><a href="#设计优势" class="headerlink" title="设计优势"></a>设计优势</h4><ol><li><strong>性能优化</strong>：优先使用线程本地列表，减少锁竞争</li><li><strong>负载均衡</strong>：共享列表允许线程间共享连接</li><li><strong>及时响应</strong>：等待队列直接交付，减少唤醒延迟</li><li><strong>无锁设计</strong>：大量使用 CAS，避免传统锁的开销</li><li><strong>自适应</strong>：根据等待线程数动态创建连接</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HikariCP 的连接池设计体现了以下核心思想：</p><ol><li><strong>无锁优先</strong>：尽可能使用无锁设计（CAS、ThreadLocal）</li><li><strong>读多写少优化</strong>：针对连接池场景优化（CopyOnWriteArrayList）</li><li><strong>三层查找</strong>：线程本地 → 共享列表 → 等待队列</li><li><strong>直接交付</strong>：使用 handoffQueue 减少延迟</li><li><strong>健康检查</strong>：aliveBypassWindowMs 平衡性能和可靠性</li></ol><p>这些设计使得 HikariCP 在保证线程安全的同时，实现了极高的并发性能。</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>HikariCP 源码：<code>src/main/java/com/zaxxer/hikari/</code></li><li>关键类：<ul><li><code>HikariPool.java</code>：连接池主类</li><li><code>ConcurrentBag.java</code>：连接容器</li><li><code>PoolEntry.java</code>：连接条目</li><li><code>ProxyConnection.java</code>：代理连接</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HikariCP-连接池详解&quot;&gt;&lt;a href=&quot;#HikariCP-连接池详解&quot; class=&quot;headerlink&quot; title=&quot;HikariCP 连接池详解&quot;&gt;&lt;/a&gt;HikariCP 连接池详解&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>注册中心协议详解：Raft、Distro、Gossip</title>
    <link href="https://zhsongdanc.github.io/posts/105.html"/>
    <id>https://zhsongdanc.github.io/posts/105.html</id>
    <published>2025-01-20T02:30:07.000Z</published>
    <updated>2025-11-24T11:47:10.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注册中心协议详解：Raft、Distro、Gossip"><a href="#注册中心协议详解：Raft、Distro、Gossip" class="headerlink" title="注册中心协议详解：Raft、Distro、Gossip"></a>注册中心协议详解：Raft、Distro、Gossip</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1-一致性模型强一致性与最终一致性">一致性模型：强一致性与最终一致性</a></li><li><a href="#2-为什么注册中心选择最终一致性">为什么注册中心选择最终一致性</a></li><li><a href="#3-raft-协议原理">Raft 协议原理</a></li><li><a href="#4-nacos-distro-协议原理">Nacos Distro 协议原理</a></li><li><a href="#5-redis-cluster-gossip-协议原理">Redis Cluster Gossip 协议原理</a></li><li><a href="#6-三种协议对比">三种协议对比</a></li><li><a href="#7-网络分区的影响">网络分区的影响</a></li></ol><hr><h2 id="1-一致性模型：强一致性与最终一致性"><a href="#1-一致性模型：强一致性与最终一致性" class="headerlink" title="1. 一致性模型：强一致性与最终一致性"></a>1. 一致性模型：强一致性与最终一致性</h2><h3 id="1-1-强一致性（Strong-Consistency）"><a href="#1-1-强一致性（Strong-Consistency）" class="headerlink" title="1.1 强一致性（Strong Consistency）"></a>1.1 强一致性（Strong Consistency）</h3><p><strong>简单理解</strong>：所有节点在同一时刻看到相同的数据，就像”同步更新”。</p><p><strong>特点</strong>：</p><ul><li>写入后，所有节点立即同步</li><li>读取时，所有节点返回相同结果</li><li>需要等待所有节点确认，延迟较高</li></ul><p><strong>举个例子</strong>：</p><pre><code>你更新了服务A的地址为 192.168.1.100↓注册中心必须等待所有节点都更新完成↓只有所有节点都确认更新后，才返回"更新成功"↓此时任何节点读取，都是 192.168.1.100</code></pre><p><strong>优点</strong>：数据一致，不会读到旧数据<br><strong>缺点</strong>：性能较低，需要等待所有节点同步</p><h3 id="1-2-最终一致性（Eventual-Consistency）"><a href="#1-2-最终一致性（Eventual-Consistency）" class="headerlink" title="1.2 最终一致性（Eventual Consistency）"></a>1.2 最终一致性（Eventual Consistency）</h3><p><strong>简单理解</strong>：允许短暂不一致，但最终会一致，就像”异步更新”。</p><p><strong>特点</strong>：</p><ul><li>写入后，先返回成功，再异步同步到其他节点</li><li>读取时，可能暂时读到旧数据</li><li>延迟低，性能好</li></ul><p><strong>举个例子</strong>：</p><pre><code>你更新了服务A的地址为 192.168.1.100↓注册中心立即返回"更新成功"↓但此时：  - 节点1已经更新为 192.168.1.100 ✅  - 节点2还是旧的 192.168.1.99 ⏳（正在同步）  - 节点3还是旧的 192.168.1.99 ⏳（正在同步）↓过一会儿，所有节点都同步完成，最终一致</code></pre><p><strong>优点</strong>：性能好，响应快<br><strong>缺点</strong>：可能短暂读到旧数据</p><h3 id="1-3-对比表格"><a href="#1-3-对比表格" class="headerlink" title="1.3 对比表格"></a>1.3 对比表格</h3><table><thead><tr><th>特性</th><th>强一致性</th><th>最终一致性</th></tr></thead><tbody><tr><td><strong>数据同步时机</strong></td><td>立即同步（同步）</td><td>延迟同步（异步）</td></tr><tr><td><strong>读取一致性</strong></td><td>总是读到最新</td><td>可能读到旧数据</td></tr><tr><td><strong>性能</strong></td><td>较慢（需要等待）</td><td>较快（立即返回）</td></tr><tr><td><strong>可用性</strong></td><td>较低（节点故障影响大）</td><td>较高（节点故障影响小）</td></tr><tr><td><strong>适用场景</strong></td><td>金融、支付等对一致性要求极高的场景</td><td>服务注册、配置中心等可容忍短暂不一致的场景</td></tr></tbody></table><hr><h2 id="2-为什么注册中心选择最终一致性"><a href="#2-为什么注册中心选择最终一致性" class="headerlink" title="2. 为什么注册中心选择最终一致性"></a>2. 为什么注册中心选择最终一致性</h2><h3 id="2-1-服务通常有多个实例（冗余保护）"><a href="#2-1-服务通常有多个实例（冗余保护）" class="headerlink" title="2.1 服务通常有多个实例（冗余保护）"></a>2.1 服务通常有多个实例（冗余保护）</h3><p><strong>关键点</strong>：一个服务通常部署多个实例，即使读到旧地址，其他实例仍可用。</p><p><strong>举个例子</strong>：</p><pre><code>服务A有3个实例：- 实例1：192.168.1.10:8080- 实例2：192.168.1.11:8080  - 实例3：192.168.1.12:8080现在实例1下线了，但注册中心还没同步：- 节点A（已更新）：只返回实例2和实例3 ✅- 节点B（未更新）：返回实例1、2、3（包含已下线的实例1）❌客户端从节点B获取到实例1的地址，调用失败↓但客户端通常有重试机制，会尝试实例2或实例3↓最终调用成功，影响很小</code></pre><h3 id="2-2-服务地址变化不频繁"><a href="#2-2-服务地址变化不频繁" class="headerlink" title="2.2 服务地址变化不频繁"></a>2.2 服务地址变化不频繁</h3><p><strong>关键点</strong>：服务注册/注销不是高频操作，短暂不一致窗口内发生变化的概率很低。</p><p><strong>时间线分析</strong>：</p><pre><code>假设服务注册/注销的频率：- 服务上线：可能一天几次，甚至几天一次- 服务下线：同样不频繁- 服务地址变更：更少见最终一致性的同步时间：- 通常几秒内就能同步完成（比如3-5秒）在这3-5秒内，恰好有服务注册/注销的概率很低↓所以大部分情况下，即使短暂不一致，也不会造成实际影响</code></pre><h3 id="2-3-客户端有缓存和重试机制"><a href="#2-3-客户端有缓存和重试机制" class="headerlink" title="2.3 客户端有缓存和重试机制"></a>2.3 客户端有缓存和重试机制</h3><p><strong>关键点</strong>：客户端不会每次都去注册中心查询，通常有本地缓存。</p><p><strong>工作流程</strong>：</p><pre><code>客户端启动时：1. 从注册中心获取服务列表2. 缓存到本地（比如缓存30秒）客户端调用时：1. 先使用本地缓存的服务列表2. 如果调用失败，才重新从注册中心获取3. 有重试机制，会尝试多个实例即使注册中心短暂不一致：- 客户端大部分时候用的是本地缓存- 缓存更新有延迟，本身就容忍了短暂不一致</code></pre><h3 id="2-4-服务调用有超时和熔断保护"><a href="#2-4-服务调用有超时和熔断保护" class="headerlink" title="2.4 服务调用有超时和熔断保护"></a>2.4 服务调用有超时和熔断保护</h3><p><strong>关键点</strong>：即使调用到已下线的服务，也有超时和熔断机制保护。</p><p><strong>容错流程</strong>：</p><pre><code>客户端调用已下线的服务实例↓连接超时（比如2秒）↓触发重试机制，尝试下一个实例↓或者触发熔断器，暂时跳过该服务↓整体影响：只是延迟了几秒，不会导致系统崩溃</code></pre><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><p>注册中心短时间内不一致影响较低，主要因为：</p><ol><li>✅ <strong>服务多实例冗余</strong>：即使读到旧地址，其他实例仍可用</li><li>✅ <strong>服务地址变化不频繁</strong>：短暂不一致窗口内发生变化的概率低</li><li>✅ <strong>客户端有缓存和重试</strong>：本地缓存和重试机制提供容错</li><li>✅ <strong>有超时和熔断保护</strong>：调用失败有保护机制</li><li>✅ <strong>注册中心本身的高可用设计</strong>：多节点部署，即使某个节点数据不一致，其他节点可能是最新的</li></ol><p><strong>核心思想</strong>：通过架构设计（多实例、缓存、重试）和业务特点（变化不频繁、可容忍短暂失败），将一致性要求从”必须立即一致”降低到”最终一致即可”，从而获得更好的性能和可用性。</p><hr><h2 id="3-Raft-协议原理"><a href="#3-Raft-协议原理" class="headerlink" title="3. Raft 协议原理"></a>3. Raft 协议原理</h2><h3 id="3-1-核心思想：选举-日志复制"><a href="#3-1-核心思想：选举-日志复制" class="headerlink" title="3.1 核心思想：选举 + 日志复制"></a>3.1 核心思想：选举 + 日志复制</h3><p>Raft 通过选举产生 Leader，由 Leader 处理写请求并复制日志，实现强一致性。</p><h3 id="3-2-工作流程"><a href="#3-2-工作流程" class="headerlink" title="3.2 工作流程"></a>3.2 工作流程</h3><h4 id="3-2-1-Leader-选举（选老大）"><a href="#3-2-1-Leader-选举（选老大）" class="headerlink" title="3.2.1 Leader 选举（选老大）"></a>3.2.1 Leader 选举（选老大）</h4><pre><code>初始状态：3个节点都是 Follower（跟随者）↓某个节点超时没收到 Leader 的心跳↓变成 Candidate（候选人），发起选举↓向其他节点拉票："选我当 Leader！"↓获得多数票（比如3个节点中2个同意）↓成为 Leader，开始处理写请求</code></pre><p><strong>关键点</strong>：</p><ul><li>需要多数票（N/2 + 1）才能当选</li><li>保证同时只有一个 Leader（避免脑裂）</li></ul><h4 id="3-2-2-日志复制（写数据）"><a href="#3-2-2-日志复制（写数据）" class="headerlink" title="3.2.2 日志复制（写数据）"></a>3.2.2 日志复制（写数据）</h4><pre><code>客户端写请求 → Leader↓Leader 先写本地日志（未提交）↓Leader 向所有 Follower 发送日志↓等待多数节点确认（包括自己）↓提交日志（数据生效）↓通知所有 Follower 提交↓返回客户端"写入成功"</code></pre><p><strong>关键点</strong>：</p><ul><li>必须等多数节点确认才提交</li><li>保证强一致性：所有节点看到相同数据</li></ul><h4 id="3-2-3-状态机"><a href="#3-2-3-状态机" class="headerlink" title="3.2.3 状态机"></a>3.2.3 状态机</h4><pre><code>日志（已提交） → 状态机 → 实际数据</code></pre><h3 id="3-3-适用场景"><a href="#3-3-适用场景" class="headerlink" title="3.3 适用场景"></a>3.3 适用场景</h3><p><strong>需要强一致性的场景</strong>：</p><ul><li>配置中心（配置变更必须立即生效）</li><li>元数据管理（不能容忍数据不一致）</li><li>分布式锁（需要强一致性保证）</li></ul><p><strong>典型产品</strong>：</p><ul><li>Consul（使用 Raft）</li><li>etcd（使用 Raft）</li><li>Nacos CP 模式（使用 Raft）</li></ul><hr><h2 id="4-Nacos-Distro-协议原理"><a href="#4-Nacos-Distro-协议原理" class="headerlink" title="4. Nacos Distro 协议原理"></a>4. Nacos Distro 协议原理</h2><h3 id="4-1-核心思想：分片-异步复制"><a href="#4-1-核心思想：分片-异步复制" class="headerlink" title="4.1 核心思想：分片 + 异步复制"></a>4.1 核心思想：分片 + 异步复制</h3><p>Distro 将数据分片，每个节点负责部分数据，节点间异步复制，实现最终一致性。</p><h3 id="4-2-数据存储机制"><a href="#4-2-数据存储机制" class="headerlink" title="4.2 数据存储机制"></a>4.2 数据存储机制</h3><p><strong>核心特点</strong>：</p><ol><li><strong>每个节点存储所有数据</strong>（全量存储）</li><li><strong>每个节点只负责部分数据的写请求</strong>（分片写）</li><li><strong>通过异步复制保持最终一致</strong></li></ol><h3 id="4-3-工作流程"><a href="#4-3-工作流程" class="headerlink" title="4.3 工作流程"></a>4.3 工作流程</h3><h4 id="4-3-1-数据分片（分工）"><a href="#4-3-1-数据分片（分工）" class="headerlink" title="4.3.1 数据分片（分工）"></a>4.3.1 数据分片（分工）</h4><pre><code>假设有3个节点：- 节点A：负责服务名 hash % 3 == 0 的服务- 节点B：负责服务名 hash % 3 == 1 的服务  - 节点C：负责服务名 hash % 3 == 2 的服务例如：- "user-service" → hash("user-service") % 3 = 1 → 节点B负责- "order-service" → hash("order-service") % 3 = 2 → 节点C负责</code></pre><p><strong>关键点</strong>：</p><ul><li>每个服务有唯一负责节点（责任节点）</li><li>其他节点可以读，但不能直接写</li></ul><h4 id="4-3-2-写请求处理（责任节点写）"><a href="#4-3-2-写请求处理（责任节点写）" class="headerlink" title="4.3.2 写请求处理（责任节点写）"></a>4.3.2 写请求处理（责任节点写）</h4><pre><code>客户端写请求 → 任意节点（比如节点A）↓节点A检查：这个服务我负责吗？  - 是 → 直接写入本地，返回成功  - 否 → 转发给责任节点（比如节点B）↓责任节点（节点B）写入本地↓立即返回成功（不等待其他节点）↓异步复制到其他节点（后台任务）</code></pre><p><strong>关键点</strong>：</p><ul><li>写请求必须由责任节点处理</li><li>立即返回，不等待复制完成</li></ul><h4 id="4-3-3-异步复制（最终一致）"><a href="#4-3-3-异步复制（最终一致）" class="headerlink" title="4.3.3 异步复制（最终一致）"></a>4.3.3 异步复制（最终一致）</h4><pre><code>责任节点写入后↓后台任务定期复制数据到其他节点↓其他节点收到后更新本地数据↓最终所有节点数据一致</code></pre><p><strong>关键点</strong>：</p><ul><li>异步复制，不阻塞写请求</li><li>最终一致性，可能短暂不一致</li></ul><h4 id="4-3-4-读请求处理（任意节点可读）"><a href="#4-3-4-读请求处理（任意节点可读）" class="headerlink" title="4.3.4 读请求处理（任意节点可读）"></a>4.3.4 读请求处理（任意节点可读）</h4><pre><code>客户端读请求 → 任意节点（比如节点B）↓节点B：我有这个数据的副本，直接返回↓可能返回的是旧数据（如果责任节点刚更新，还没复制过来）↓但通常影响不大（最终会一致）</code></pre><h3 id="4-4-为什么这样设计？"><a href="#4-4-为什么这样设计？" class="headerlink" title="4.4 为什么这样设计？"></a>4.4 为什么这样设计？</h3><p><strong>优点</strong>：</p><ol><li>✅ <strong>读性能好</strong>：任意节点可读，无需路由到特定节点</li><li>✅ <strong>高可用</strong>：任意节点故障，其他节点仍可读</li><li>✅ <strong>写性能好</strong>：责任节点立即返回，不等待复制</li></ol><p><strong>缺点</strong>：</p><ol><li>❌ <strong>存储空间</strong>：每个节点存储全量数据</li><li>❌ <strong>最终一致性</strong>：可能读到旧数据</li></ol><h3 id="4-5-适用场景"><a href="#4-5-适用场景" class="headerlink" title="4.5 适用场景"></a>4.5 适用场景</h3><p><strong>可以容忍最终一致性的场景</strong>：</p><ul><li>服务注册中心（服务地址变化不频繁）</li><li>服务发现（有多个实例，短暂不一致影响小）</li><li>非关键配置（可以容忍短暂延迟）</li></ul><p><strong>典型产品</strong>：</p><ul><li>Nacos AP 模式（使用 Distro）</li></ul><hr><h2 id="5-Redis-Cluster-Gossip-协议原理"><a href="#5-Redis-Cluster-Gossip-协议原理" class="headerlink" title="5. Redis Cluster Gossip 协议原理"></a>5. Redis Cluster Gossip 协议原理</h2><h3 id="5-1-核心思想：去中心化的信息传播"><a href="#5-1-核心思想：去中心化的信息传播" class="headerlink" title="5.1 核心思想：去中心化的信息传播"></a>5.1 核心思想：去中心化的信息传播</h3><p>Gossip 像”流言传播”：节点随机选择其他节点交换信息，逐步扩散到整个集群。</p><h3 id="5-2-工作流程"><a href="#5-2-工作流程" class="headerlink" title="5.2 工作流程"></a>5.2 工作流程</h3><h4 id="5-2-1-定期随机通信"><a href="#5-2-1-定期随机通信" class="headerlink" title="5.2.1 定期随机通信"></a>5.2.1 定期随机通信</h4><pre><code>节点A：每1秒随机选择一个节点（比如节点C）↓节点A → 节点C："我这里有这些数据..."↓节点C → 节点A："我这里有这些数据..."↓双方交换信息，更新本地数据</code></pre><h4 id="5-2-2-信息传播过程"><a href="#5-2-2-信息传播过程" class="headerlink" title="5.2.2 信息传播过程"></a>5.2.2 信息传播过程</h4><pre><code>初始状态：- 节点A：知道服务1、服务2- 节点B：知道服务3- 节点C：知道服务4第1轮传播：节点A随机选择节点B↓A告诉B：我有服务1、服务2B告诉A：我有服务3↓结果：- 节点A：知道服务1、2、3- 节点B：知道服务1、2、3- 节点C：知道服务4第2轮传播：节点B随机选择节点C↓B告诉C：我有服务1、2、3C告诉B：我有服务4↓最终：所有节点都知道所有服务</code></pre><p><strong>关键点</strong>：</p><ul><li>不需要中心节点</li><li>通过随机通信逐步传播</li><li>最终所有节点信息一致</li></ul><h3 id="5-3-Redis-Cluster-如何使用-Gossip"><a href="#5-3-Redis-Cluster-如何使用-Gossip" class="headerlink" title="5.3 Redis Cluster 如何使用 Gossip"></a>5.3 Redis Cluster 如何使用 Gossip</h3><h4 id="5-3-1-集群状态传播"><a href="#5-3-1-集群状态传播" class="headerlink" title="5.3.1 集群状态传播"></a>5.3.1 集群状态传播</h4><pre><code>节点A发现：节点D故障了↓节点A更新本地集群状态↓节点A随机选择节点B，告诉B："节点D故障了"↓节点B更新本地状态，继续传播给其他节点↓最终所有节点都知道节点D故障</code></pre><h4 id="5-3-2-槽位（Slot）信息传播"><a href="#5-3-2-槽位（Slot）信息传播" class="headerlink" title="5.3.2 槽位（Slot）信息传播"></a>5.3.2 槽位（Slot）信息传播</h4><pre><code>Redis Cluster 有16384个槽位- 节点A：负责槽位 0-5460- 节点B：负责槽位 5461-10922- 节点C：负责槽位 10923-16383每个节点通过 Gossip 告诉其他节点："我负责哪些槽位"↓所有节点都知道槽位的分布↓客户端请求时，可以路由到正确的节点</code></pre><h4 id="5-3-3-数据存储：分片存储"><a href="#5-3-3-数据存储：分片存储" class="headerlink" title="5.3.3 数据存储：分片存储"></a>5.3.3 数据存储：分片存储</h4><p><strong>关键点</strong>：</p><ul><li>Hash 决定”数据存在哪里”</li><li>只有负责该槽位的节点存储数据</li><li>读请求必须路由到存储数据的节点</li></ul><p><strong>例子</strong>：</p><pre><code>写请求：SET user:1 "张三"↓计算：hash("user:1") % 16384 = 5000（槽位）↓查找：槽位5000分配给节点B↓数据只写入节点B↓节点A和节点C不存储这个数据</code></pre><h3 id="5-4-适用场景"><a href="#5-4-适用场景" class="headerlink" title="5.4 适用场景"></a>5.4 适用场景</h3><p><strong>完全去中心化，无单点故障</strong>：</p><ul><li>Redis Cluster（分布式缓存）</li><li>Cassandra（分布式数据库）</li><li>Consul（服务发现，部分使用）</li></ul><hr><h2 id="6-三种协议对比"><a href="#6-三种协议对比" class="headerlink" title="6. 三种协议对比"></a>6. 三种协议对比</h2><h3 id="6-1-核心区别总结"><a href="#6-1-核心区别总结" class="headerlink" title="6.1 核心区别总结"></a>6.1 核心区别总结</h3><table><thead><tr><th>维度</th><th>Raft</th><th>Distro</th><th>Gossip</th></tr></thead><tbody><tr><td><strong>一致性</strong></td><td>强一致性</td><td>最终一致性</td><td>最终一致性</td></tr><tr><td><strong>数据存储</strong></td><td>全量存储</td><td>全量存储</td><td>分片存储</td></tr><tr><td><strong>写请求</strong></td><td>Leader处理，同步复制</td><td>责任节点处理，异步复制</td><td>负责节点处理，不复制数据</td></tr><tr><td><strong>读请求</strong></td><td>Leader或Follower</td><td>任意节点可读</td><td>需要路由到负责节点</td></tr><tr><td><strong>通信方式</strong></td><td>Leader主动复制</td><td>责任节点主动复制</td><td>随机节点互相交换</td></tr><tr><td><strong>同步内容</strong></td><td>数据本身</td><td>数据本身</td><td>状态信息/元数据</td></tr><tr><td><strong>中心化</strong></td><td>半中心化（有Leader）</td><td>半中心化（有责任节点）</td><td>完全去中心化</td></tr><tr><td><strong>性能</strong></td><td>较慢（需要等待确认）</td><td>较快（立即返回）</td><td>较快（立即返回）</td></tr></tbody></table><h3 id="6-2-Distro-vs-Gossip-的关键区别"><a href="#6-2-Distro-vs-Gossip-的关键区别" class="headerlink" title="6.2 Distro vs Gossip 的关键区别"></a>6.2 Distro vs Gossip 的关键区别</h3><h4 id="6-2-1-数据存储方式"><a href="#6-2-1-数据存储方式" class="headerlink" title="6.2.1 数据存储方式"></a>6.2.1 数据存储方式</h4><p><strong>Distro</strong>：</p><ul><li>全量存储：每个节点存储所有数据</li><li>所有节点都有完整副本</li></ul><p><strong>Redis Cluster Gossip</strong>：</p><ul><li>分片存储：每个节点只存储部分数据</li><li>数据分散在不同节点</li></ul><h4 id="6-2-2-同步-传播机制"><a href="#6-2-2-同步-传播机制" class="headerlink" title="6.2.2 同步/传播机制"></a>6.2.2 同步/传播机制</h4><p><strong>Distro</strong>：</p><pre><code>责任节点写入数据↓后台任务：主动复制数据到所有其他节点  - 节点A → 节点B（复制数据）  - 节点A → 节点C（复制数据）↓其他节点收到完整数据</code></pre><p><strong>Redis Cluster Gossip</strong>：</p><pre><code>负责节点写入数据↓通过 Gossip 传播的是"状态信息"，不是数据本身  - 节点A → 节点B："我负责槽位5000，数据已更新"  - 节点B → 节点C："节点A负责槽位5000"↓其他节点知道"数据在哪里"，但不存储数据</code></pre><p><strong>关键区别</strong>：</p><ul><li><strong>Distro</strong>：传播的是数据本身（复制数据）</li><li><strong>Gossip</strong>：传播的是元数据/状态信息（告诉别人数据在哪里）</li></ul><h4 id="6-2-3-Hash-的作用区别"><a href="#6-2-3-Hash-的作用区别" class="headerlink" title="6.2.3 Hash 的作用区别"></a>6.2.3 Hash 的作用区别</h4><p><strong>Distro</strong>：</p><pre><code>hash(服务名) % 节点数 = 责任节点编号含义：这个节点负责写这个服务但：所有节点最终都会存储这个服务的数据</code></pre><p><strong>Redis Cluster</strong>：</p><pre><code>hash(key) % 16384 = 槽位编号含义：这个槽位存储这个key的数据但：只有负责这个槽位的节点存储数据</code></pre><p><strong>简单记忆</strong>：</p><ul><li><strong>Distro</strong>：hash 选”写手”，数据大家都有</li><li><strong>Redis Cluster</strong>：hash 选”仓库”，数据只在一个地方</li></ul><h3 id="6-3-为什么-Nacos-提供两种模式？"><a href="#6-3-为什么-Nacos-提供两种模式？" class="headerlink" title="6.3 为什么 Nacos 提供两种模式？"></a>6.3 为什么 Nacos 提供两种模式？</h3><p><strong>CP 模式（Raft）</strong>：配置管理</p><ul><li>配置变更需要强一致</li><li>配置错误影响大</li><li>使用 Raft 保证一致性</li></ul><p><strong>AP 模式（Distro）</strong>：服务注册发现</p><ul><li>服务注册发现可容忍短暂不一致</li><li>性能要求高</li><li>使用 Distro 提升性能</li></ul><h3 id="6-4-为什么-Redis-Cluster-用-Gossip-而不用-Distro？"><a href="#6-4-为什么-Redis-Cluster-用-Gossip-而不用-Distro？" class="headerlink" title="6.4 为什么 Redis Cluster 用 Gossip 而不用 Distro？"></a>6.4 为什么 Redis Cluster 用 Gossip 而不用 Distro？</h3><p><strong>原因</strong>：</p><ol><li><strong>数据规模</strong>：数据量可能非常大（TB级别），全量存储不现实</li><li><strong>读模式</strong>：读请求需要知道数据在哪个节点，通过槽位路由到正确节点</li><li><strong>一致性要求</strong>：可以容忍最终一致性，通过 Gossip 传播状态信息</li></ol><hr><h2 id="7-网络分区的影响"><a href="#7-网络分区的影响" class="headerlink" title="7. 网络分区的影响"></a>7. 网络分区的影响</h2><h3 id="7-1-什么是网络分区？"><a href="#7-1-什么是网络分区？" class="headerlink" title="7.1 什么是网络分区？"></a>7.1 什么是网络分区？</h3><p>网络分区（Network Partition）指集群被分割成多个无法通信的子集。</p><pre><code>正常情况：节点A ←→ 节点B ←→ 节点C（所有节点可以互相通信）网络分区后：分区1：节点A ←→ 节点B分区2：节点C（孤立）（分区1和分区2无法通信）</code></pre><h3 id="7-2-Distro-协议在网络分区下的影响"><a href="#7-2-Distro-协议在网络分区下的影响" class="headerlink" title="7.2 Distro 协议在网络分区下的影响"></a>7.2 Distro 协议在网络分区下的影响</h3><h4 id="7-2-1-场景：3个节点，网络分区成-2-1"><a href="#7-2-1-场景：3个节点，网络分区成-2-1" class="headerlink" title="7.2.1 场景：3个节点，网络分区成 2+1"></a>7.2.1 场景：3个节点，网络分区成 2+1</h4><pre><code>分区1：节点A、节点B（可以互相通信）分区2：节点C（孤立）</code></pre><h4 id="7-2-2-写请求的影响"><a href="#7-2-2-写请求的影响" class="headerlink" title="7.2.2 写请求的影响"></a>7.2.2 写请求的影响</h4><p><strong>情况1：写请求到分区1（节点A或B）</strong></p><pre><code>客户端 → 节点A（写 user-service）↓节点A计算：hash("user-service") % 3 = 1 → 节点B负责↓节点A转发给节点B↓节点B写入本地，返回成功↓节点B尝试复制到节点A（成功）和节点C（失败，网络不通）↓结果：- 分区1（节点A、B）：有最新数据 ✅- 分区2（节点C）：没有最新数据 ❌</code></pre><p><strong>情况2：写请求到分区2（节点C）</strong></p><pre><code>客户端 → 节点C（写 order-service）↓节点C计算：hash("order-service") % 3 = 0 → 节点A负责↓节点C尝试转发给节点A（失败，网络不通）↓结果：写请求失败 ❌</code></pre><h4 id="7-2-3-读请求的影响"><a href="#7-2-3-读请求的影响" class="headerlink" title="7.2.3 读请求的影响"></a>7.2.3 读请求的影响</h4><pre><code>客户端 → 节点A（读 user-service）↓节点A有数据（通过分区1内的复制获得）↓返回数据（可能是最新的，也可能不是）↓结果：分区1可以正常读，但可能读到旧数据</code></pre><h4 id="7-2-4-Distro-的处理策略"><a href="#7-2-4-Distro-的处理策略" class="headerlink" title="7.2.4 Distro 的处理策略"></a>7.2.4 Distro 的处理策略</h4><p><strong>AP 模式（可用性优先）</strong>：</p><pre><code>网络分区时：- 允许分区1继续提供服务（可用性）- 接受数据不一致（最终一致性）- 网络恢复后，通过异步复制同步数据</code></pre><p><strong>关键点</strong>：</p><ul><li>优先保证可用性</li><li>容忍数据不一致</li><li>网络恢复后最终一致</li></ul><h3 id="7-3-Redis-Cluster-Gossip-在网络分区下的影响"><a href="#7-3-Redis-Cluster-Gossip-在网络分区下的影响" class="headerlink" title="7.3 Redis Cluster Gossip 在网络分区下的影响"></a>7.3 Redis Cluster Gossip 在网络分区下的影响</h3><h4 id="7-3-1-场景：6个节点（3主3从），网络分区成-3-3"><a href="#7-3-1-场景：6个节点（3主3从），网络分区成-3-3" class="headerlink" title="7.3.1 场景：6个节点（3主3从），网络分区成 3+3"></a>7.3.1 场景：6个节点（3主3从），网络分区成 3+3</h4><pre><code>分区1：主节点A、主节点B、主节点C（可以互相通信）分区2：从节点A'、从节点B'、从节点C'（可以互相通信）</code></pre><h4 id="7-3-2-写请求的影响"><a href="#7-3-2-写请求的影响" class="headerlink" title="7.3.2 写请求的影响"></a>7.3.2 写请求的影响</h4><p><strong>情况1：写请求到分区1（主节点）</strong></p><pre><code>客户端 → 主节点A（SET user:1 "张三"）↓主节点A计算：hash("user:1") % 16384 = 5000↓主节点A负责槽位5000，直接写入↓返回成功↓尝试复制到从节点A'（失败，网络不通）↓结果：- 分区1（主节点）：有最新数据 ✅- 分区2（从节点）：没有最新数据 ❌</code></pre><p><strong>情况2：写请求到分区2（从节点）</strong></p><pre><code>客户端 → 从节点A'（SET user:1 "张三"）↓从节点A'：我是从节点，不能写↓返回错误：READONLY↓结果：写请求失败 ❌</code></pre><h4 id="7-3-3-故障检测和故障转移"><a href="#7-3-3-故障检测和故障转移" class="headerlink" title="7.3.3 故障检测和故障转移"></a>7.3.3 故障检测和故障转移</h4><p><strong>分区1（主节点）</strong>：</p><pre><code>主节点A、B、C通过 Gossip 互相通信↓发现从节点A'、B'、C'都失联了↓但主节点之间可以通信，继续提供服务↓结果：分区1可以正常读写</code></pre><p><strong>分区2（从节点）</strong>：</p><pre><code>从节点A'、B'、C'通过 Gossip 互相通信↓发现主节点A、B、C都失联了↓触发故障转移：  - 从节点A'升级为主节点（接管主节点A的槽位）  - 从节点B'升级为主节点（接管主节点B的槽位）  - 从节点C'升级为主节点（接管主节点C的槽位）↓结果：分区2也可以提供服务，但数据可能不一致</code></pre><h4 id="7-3-4-脑裂问题（Split-Brain）"><a href="#7-3-4-脑裂问题（Split-Brain）" class="headerlink" title="7.3.4 脑裂问题（Split-Brain）"></a>7.3.4 脑裂问题（Split-Brain）</h4><pre><code>网络分区后：- 分区1认为：主节点A、B、C是主节点- 分区2认为：从节点A'、B'、C'已升级为主节点两个分区都认为自己是"正确的"↓可能出现：- 同一个key在两个分区都有不同的值- 客户端可能连接到不同分区，读到不同数据</code></pre><h4 id="7-3-5-Redis-Cluster-的处理策略"><a href="#7-3-5-Redis-Cluster-的处理策略" class="headerlink" title="7.3.5 Redis Cluster 的处理策略"></a>7.3.5 Redis Cluster 的处理策略</h4><p><strong>需要多数节点确认</strong>：</p><pre><code>Redis Cluster 要求：- 故障转移需要多数节点确认- 如果分区2的节点数 &lt; 总节点数/2，不能升级为主节点- 避免脑裂问题</code></pre><p><strong>关键点</strong>：</p><ul><li>优先保证一致性（避免脑裂）</li><li>少数分区可能无法提供服务</li><li>网络恢复后需要数据同步</li></ul><h3 id="7-4-对比总结"><a href="#7-4-对比总结" class="headerlink" title="7.4 对比总结"></a>7.4 对比总结</h3><table><thead><tr><th>维度</th><th>Distro</th><th>Redis Cluster Gossip</th></tr></thead><tbody><tr><td><strong>多数分区</strong></td><td>可以继续提供服务 ✅</td><td>可以继续提供服务 ✅</td></tr><tr><td><strong>少数分区</strong></td><td>可能无法写，但可以读 ⚠️</td><td>可能无法提供服务 ❌</td></tr><tr><td><strong>可用性</strong></td><td>较高（AP模式）</td><td>中等（需要多数节点）</td></tr><tr><td><strong>数据一致性</strong></td><td>分区内一致，跨分区不一致</td><td>分区内一致，跨分区可能不一致</td></tr><tr><td><strong>脑裂问题</strong></td><td>可能（两个分区都提供服务）</td><td>可能（但通过多数节点机制缓解）</td></tr></tbody></table><h3 id="7-5-网络恢复后的处理"><a href="#7-5-网络恢复后的处理" class="headerlink" title="7.5 网络恢复后的处理"></a>7.5 网络恢复后的处理</h3><p><strong>Distro</strong>：</p><pre><code>网络恢复↓节点C发现节点A、B有最新数据↓节点C从节点A或B复制最新数据↓最终所有节点数据一致 ✅</code></pre><p><strong>Redis Cluster Gossip</strong>：</p><pre><code>网络恢复↓发现有两个"主节点"（原主节点A和升级的从节点A'）↓需要人工介入或自动解决冲突↓确定哪个是真正的主节点↓同步数据，恢复一致性</code></pre><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h3><ol><li><p><strong>一致性模型</strong>：</p><ul><li>强一致性：所有节点立即同步，性能较低</li><li>最终一致性：异步同步，性能较好，适合注册中心</li></ul></li><li><p><strong>Raft 协议</strong>：</p><ul><li>通过选举和同步复制实现强一致性</li><li>适合对一致性要求高的场景（配置中心）</li></ul></li><li><p><strong>Distro 协议</strong>：</p><ul><li>全量存储，责任节点写，异步复制</li><li>适合服务注册发现（AP模式）</li></ul></li><li><p><strong>Gossip 协议</strong>：</p><ul><li>完全去中心化，随机传播状态信息</li><li>适合大规模分布式系统（Redis Cluster）</li></ul></li><li><p><strong>网络分区</strong>：</p><ul><li>Distro：优先可用性，容忍不一致</li><li>Redis Cluster：通过多数节点机制，在一致性和可用性之间平衡</li></ul></li></ol><h3 id="选择建议"><a href="#选择建议" class="headerlink" title="选择建议"></a>选择建议</h3><ul><li><strong>需要强一致性</strong>：选择 Raft（如配置中心）</li><li><strong>服务注册发现</strong>：选择 Distro（如 Nacos AP模式）</li><li><strong>大规模分布式缓存</strong>：选择 Gossip（如 Redis Cluster）</li></ul><hr><p><em>本文档整理自注册中心协议相关技术讨论</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;注册中心协议详解：Raft、Distro、Gossip&quot;&gt;&lt;a href=&quot;#注册中心协议详解：Raft、Distro、Gossip&quot; class=&quot;headerlink&quot; title=&quot;注册中心协议详解：Raft、Distro、Gossip&quot;&gt;&lt;/a&gt;注册中心协
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java NIO Buffer 使用与实现原理</title>
    <link href="https://zhsongdanc.github.io/posts/102.html"/>
    <id>https://zhsongdanc.github.io/posts/102.html</id>
    <published>2023-10-08T02:30:07.000Z</published>
    <updated>2025-11-21T09:51:27.916Z</updated>
    
    <content type="html"><![CDATA[<p>这是第一篇博客</p><h1 id="Java-NIO-Buffer-使用与实现原理"><a href="#Java-NIO-Buffer-使用与实现原理" class="headerlink" title="Java NIO Buffer 使用与实现原理"></a>Java NIO Buffer 使用与实现原理</h1><h2 id="1-Buffer-概述"><a href="#1-Buffer-概述" class="headerlink" title="1. Buffer 概述"></a>1. Buffer 概述</h2><h3 id="1-1-什么是-Buffer"><a href="#1-1-什么是-Buffer" class="headerlink" title="1.1 什么是 Buffer"></a>1.1 什么是 Buffer</h3><p>Buffer（缓冲区）是 Java NIO 中用于与通道（Channel）进行数据交互的对象。它是一个线性的、有限的数据容器，本质上是一个数组，但提供了更丰富的操作接口。</p><h3 id="1-2-Buffer-的核心特性"><a href="#1-2-Buffer-的核心特性" class="headerlink" title="1.2 Buffer 的核心特性"></a>1.2 Buffer 的核心特性</h3><ul><li><strong>容量（Capacity）</strong>：Buffer 的最大数据容量，创建后不可改变</li><li><strong>位置（Position）</strong>：下一个要读取或写入的索引位置</li><li><strong>限制（Limit）</strong>：第一个不应该读取或写入的索引位置</li><li><strong>标记（Mark）</strong>：一个备忘位置，可以通过 <code>reset()</code> 恢复到该位置</li></ul><h3 id="1-3-Buffer-的类型"><a href="#1-3-Buffer-的类型" class="headerlink" title="1.3 Buffer 的类型"></a>1.3 Buffer 的类型</h3><p>Java NIO 提供了以下类型的 Buffer：</p><ul><li><code>ByteBuffer</code></li><li><code>CharBuffer</code></li><li><code>ShortBuffer</code></li><li><code>IntBuffer</code></li><li><code>LongBuffer</code></li><li><code>FloatBuffer</code></li><li><code>DoubleBuffer</code></li></ul><p>其中 <code>ByteBuffer</code> 是最常用的，其他类型都是基于 <code>ByteBuffer</code> 的视图。</p><h2 id="2-Buffer-的基本使用"><a href="#2-Buffer-的基本使用" class="headerlink" title="2. Buffer 的基本使用"></a>2. Buffer 的基本使用</h2><h3 id="2-1-创建-Buffer"><a href="#2-1-创建-Buffer" class="headerlink" title="2.1 创建 Buffer"></a>2.1 创建 Buffer</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方式1：分配指定容量的 Buffer（堆内存）</span>ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式2：分配直接内存 Buffer（堆外内存）</span>ByteBuffer directBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式3：包装现有数组</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>ByteBuffer wrappedBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">wrap</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-写入数据到-Buffer"><a href="#2-2-写入数据到-Buffer" class="headerlink" title="2.2 写入数据到 Buffer"></a>2.2 写入数据到 Buffer</h3><pre class="line-numbers language-java"><code class="language-java">ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式1：使用 put() 方法</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'H'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'e'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'l'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'l'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'o'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式2：批量写入</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式3：从 Channel 读取数据到 Buffer</span>channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-从-Buffer-读取数据"><a href="#2-3-从-Buffer-读取数据" class="headerlink" title="2.3 从 Buffer 读取数据"></a>2.3 从 Buffer 读取数据</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 切换为读模式</span>buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式1：逐个读取</span><span class="token keyword">while</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">hasRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span> b <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 方式2：批量读取</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>buffer<span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方式3：写入到 Channel</span>channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-Buffer-的状态转换"><a href="#2-4-Buffer-的状态转换" class="headerlink" title="2.4 Buffer 的状态转换"></a>2.4 Buffer 的状态转换</h3><pre class="line-numbers language-java"><code class="language-java">ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 初始状态：position=0, limit=capacity</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"初始: position="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写入数据后：position 移动到写入位置</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"写入后: position="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// flip()：切换为读模式，limit=position, position=0</span>buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"flip后: position="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 读取数据后：position 移动到读取位置</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"读取后: position="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// rewind()：重新读取，position=0, limit 不变</span>buffer<span class="token punctuation">.</span><span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"rewind后: position="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// clear()：清空 Buffer，position=0, limit=capacity（但数据未清除）</span>buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"clear后: position="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit="</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Buffer-核心方法详解"><a href="#3-Buffer-核心方法详解" class="headerlink" title="3. Buffer 核心方法详解"></a>3. Buffer 核心方法详解</h2><h3 id="3-1-flip-切换为读模式"><a href="#3-1-flip-切换为读模式" class="headerlink" title="3.1 flip() - 切换为读模式"></a>3.1 flip() - 切换为读模式</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Buffer <span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    limit <span class="token operator">=</span> position<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将 limit 设置为当前 position</span>    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 将 position 重置为 0</span>    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清除标记</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景</strong>：写入数据后，准备读取数据时调用。</p><h3 id="3-2-clear-清空-Buffer"><a href="#3-2-clear-清空-Buffer" class="headerlink" title="3.2 clear() - 清空 Buffer"></a>3.2 clear() - 清空 Buffer</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Buffer <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// position 重置为 0</span>    limit <span class="token operator">=</span> capacity<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// limit 设置为 capacity</span>    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清除标记</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：<code>clear()</code> 不会清除 Buffer 中的数据，只是重置了位置指针，数据仍然存在。</p><h3 id="3-3-rewind-重新读取"><a href="#3-3-rewind-重新读取" class="headerlink" title="3.3 rewind() - 重新读取"></a>3.3 rewind() - 重新读取</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Buffer <span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// position 重置为 0</span>    mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清除标记</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用场景</strong>：需要重新读取 Buffer 中的数据，但 limit 保持不变。</p><h3 id="3-4-compact-压缩-Buffer"><a href="#3-4-compact-压缩-Buffer" class="headerlink" title="3.4 compact() - 压缩 Buffer"></a>3.4 compact() - 压缩 Buffer</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> ByteBuffer <span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hb<span class="token punctuation">,</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">position</span><span class="token punctuation">(</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">limit</span><span class="token punctuation">(</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">discardMark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>作用</strong>：将未读取的数据移动到 Buffer 的开头，为后续写入腾出空间。</p><p><strong>使用场景</strong>：部分读取数据后，需要继续写入新数据。</p><h3 id="3-5-mark-和-reset-标记和重置"><a href="#3-5-mark-和-reset-标记和重置" class="headerlink" title="3.5 mark() 和 reset() - 标记和重置"></a>3.5 mark() 和 reset() - 标记和重置</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Buffer <span class="token function">mark</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mark <span class="token operator">=</span> position<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 记录当前 position</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> Buffer <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> m <span class="token operator">=</span> mark<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InvalidMarkException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    position <span class="token operator">=</span> m<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 恢复到标记位置</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-Buffer-实现原理深度剖析"><a href="#4-Buffer-实现原理深度剖析" class="headerlink" title="4. Buffer 实现原理深度剖析"></a>4. Buffer 实现原理深度剖析</h2><h3 id="4-1-Buffer-的类层次结构"><a href="#4-1-Buffer-的类层次结构" class="headerlink" title="4.1 Buffer 的类层次结构"></a>4.1 Buffer 的类层次结构</h3><pre><code>Buffer (抽象类)  ├── ByteBuffer (抽象类)  │   ├── HeapByteBuffer (堆内存实现)  │   └── DirectByteBuffer (直接内存实现)  ├── CharBuffer  ├── ShortBuffer  ├── IntBuffer  ├── LongBuffer  ├── FloatBuffer  └── DoubleBuffer</code></pre><h3 id="4-2-Buffer-核心字段"><a href="#4-2-Buffer-核心字段" class="headerlink" title="4.2 Buffer 核心字段"></a>4.2 Buffer 核心字段</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Buffer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 标记位置</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> mark <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前位置</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 限制位置</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> limit<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 容量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 地址（用于直接内存）</span>    <span class="token keyword">long</span> address<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-HeapByteBuffer-实现"><a href="#4-3-HeapByteBuffer-实现" class="headerlink" title="4.3 HeapByteBuffer 实现"></a>4.3 HeapByteBuffer 实现</h3><h4 id="4-3-1-内部结构"><a href="#4-3-1-内部结构" class="headerlink" title="4.3.1 内部结构"></a>4.3.1 内部结构</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">HeapByteBuffer</span> <span class="token keyword">extends</span> <span class="token class-name">ByteBuffer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 底层数组</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 数组偏移量</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">int</span> offset<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 是否为只读</span>    <span class="token keyword">boolean</span> isReadOnly<span class="token punctuation">;</span>    <span class="token function">HeapByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>cap<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hb 在父类中初始化</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-2-数据访问实现"><a href="#4-3-2-数据访问实现" class="headerlink" title="4.3.2 数据访问实现"></a>4.3.2 数据访问实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取数据</span><span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextGetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">checkIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 写入数据</span><span class="token keyword">public</span> ByteBuffer <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">nextPutIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> ByteBuffer <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    hb<span class="token punctuation">[</span><span class="token function">ix</span><span class="token punctuation">(</span><span class="token function">checkIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 计算实际索引</span><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">ix</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> i <span class="token operator">+</span> offset<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键点</strong>：</p><ul><li><code>HeapByteBuffer</code> 使用 Java 堆内存中的 <code>byte[]</code> 数组</li><li>所有操作都是对数组的直接访问</li><li>受 GC 管理，内存分配和回收由 JVM 控制</li></ul><h3 id="4-4-DirectByteBuffer-实现"><a href="#4-4-DirectByteBuffer-实现" class="headerlink" title="4.4 DirectByteBuffer 实现"></a>4.4 DirectByteBuffer 实现</h3><h4 id="4-4-1-内部结构"><a href="#4-4-1-内部结构" class="headerlink" title="4.4.1 内部结构"></a>4.4.1 内部结构</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">DirectByteBuffer</span> <span class="token keyword">extends</span> <span class="token class-name">MappedByteBuffer</span> <span class="token keyword">implements</span> <span class="token class-name">DirectBuffer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 直接内存地址</span>    <span class="token keyword">protected</span> <span class="token keyword">long</span> address<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 内存分配器</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Cleaner cleaner<span class="token punctuation">;</span>    <span class="token function">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> pa <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ps <span class="token operator">=</span> Bits<span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Bits<span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 分配直接内存</span>            base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> x<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        unsafe<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            address <span class="token operator">=</span> base<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 创建清理器，用于释放直接内存</span>        cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        att <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-4-2-内存分配机制"><a href="#4-4-2-内存分配机制" class="headerlink" title="4.4.2 内存分配机制"></a>4.4.2 内存分配机制</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 Unsafe 分配直接内存</span><span class="token keyword">long</span> base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 设置内存内容</span>unsafe<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 计算对齐后的地址</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    address <span class="token operator">=</span> base<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键点</strong>：</p><ul><li><code>DirectByteBuffer</code> 使用堆外内存（直接内存）</li><li>通过 <code>Unsafe.allocateMemory()</code> 分配</li><li>不受 GC 直接管理，需要手动释放</li><li>使用 <code>Cleaner</code> 机制在对象被 GC 时自动释放内存</li></ul><h4 id="4-4-3-内存释放机制"><a href="#4-4-3-内存释放机制" class="headerlink" title="4.4.3 内存释放机制"></a>4.4.3 内存释放机制</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Deallocator</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> address<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Deallocator</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">long</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">assert</span> <span class="token punctuation">(</span>address <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>address <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 释放直接内存</span>        unsafe<span class="token punctuation">.</span><span class="token function">freeMemory</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">;</span>        address <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>内存释放流程</strong>：</p><ol><li><code>DirectByteBuffer</code> 对象被 GC 回收</li><li><code>Cleaner</code> 检测到对象被回收</li><li>调用 <code>Deallocator.run()</code> 释放直接内存</li><li>调用 <code>Unsafe.freeMemory()</code> 释放内存</li></ol><h3 id="4-5-Buffer-的视图机制"><a href="#4-5-Buffer-的视图机制" class="headerlink" title="4.5 Buffer 的视图机制"></a>4.5 Buffer 的视图机制</h3><h4 id="4-5-1-创建视图"><a href="#4-5-1-创建视图" class="headerlink" title="4.5.1 创建视图"></a>4.5.1 创建视图</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建只读视图</span><span class="token keyword">public</span> ByteBuffer <span class="token function">asReadOnlyBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HeapByteBufferR</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">markValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建其他类型的视图</span><span class="token keyword">public</span> CharBuffer <span class="token function">asCharBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">remaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> off <span class="token operator">=</span> offset <span class="token operator">+</span> <span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>bigEndian            <span class="token operator">?</span> <span class="token punctuation">(</span>CharBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteBufferAsCharBufferB</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> size<span class="token punctuation">,</span> off<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token operator">:</span> <span class="token punctuation">(</span>CharBuffer<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ByteBufferAsCharBufferL</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">,</span> size<span class="token punctuation">,</span> off<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-5-2-视图共享机制"><a href="#4-5-2-视图共享机制" class="headerlink" title="4.5.2 视图共享机制"></a>4.5.2 视图共享机制</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 视图 Buffer 共享底层数组</span><span class="token keyword">class</span> <span class="token class-name">HeapByteBufferR</span> <span class="token keyword">extends</span> <span class="token class-name">HeapByteBuffer</span> <span class="token punctuation">{</span>    <span class="token function">HeapByteBufferR</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">int</span> off<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> mark<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">,</span> off<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isReadOnly <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 标记为只读</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 所有修改操作都抛出异常</span>    <span class="token keyword">public</span> ByteBuffer <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">byte</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReadOnlyBufferException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键点</strong>：</p><ul><li>视图 Buffer 共享底层数据数组</li><li>修改一个 Buffer 会影响其他视图</li><li>但每个视图有独立的 position、limit、mark</li></ul><h3 id="4-6-Buffer-的字节序（ByteOrder）"><a href="#4-6-Buffer-的字节序（ByteOrder）" class="headerlink" title="4.6 Buffer 的字节序（ByteOrder）"></a>4.6 Buffer 的字节序（ByteOrder）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ByteBuffer</span> <span class="token keyword">extends</span> <span class="token class-name">Buffer</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token operator">&lt;</span>ByteBuffer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 字节序：大端（BIG_ENDIAN）或小端（LITTLE_ENDIAN）</span>    <span class="token keyword">final</span> <span class="token keyword">boolean</span> bigEndian<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 默认使用大端序</span>    <span class="token function">ByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> mark<span class="token punctuation">,</span> <span class="token keyword">int</span> pos<span class="token punctuation">,</span> <span class="token keyword">int</span> lim<span class="token punctuation">,</span> <span class="token keyword">int</span> cap<span class="token punctuation">,</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> hb<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mark<span class="token punctuation">,</span> pos<span class="token punctuation">,</span> lim<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hb <span class="token operator">=</span> hb<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>offset <span class="token operator">=</span> offset<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>isReadOnly <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>bigEndian <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 默认大端序</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 设置字节序</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> ByteBuffer <span class="token function">order</span><span class="token punctuation">(</span>ByteOrder bo<span class="token punctuation">)</span> <span class="token punctuation">{</span>        bigEndian <span class="token operator">=</span> <span class="token punctuation">(</span>bo <span class="token operator">==</span> ByteOrder<span class="token punctuation">.</span>BIG_ENDIAN<span class="token punctuation">)</span><span class="token punctuation">;</span>        nativeByteOrder <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字节序影响</strong>：</p><ul><li>多字节数据类型（int、long 等）的存储顺序</li><li>大端序：高位字节在前（网络字节序）</li><li>小端序：低位字节在前（x86 架构默认）</li></ul><h2 id="5-Buffer-使用最佳实践"><a href="#5-Buffer-使用最佳实践" class="headerlink" title="5. Buffer 使用最佳实践"></a>5. Buffer 使用最佳实践</h2><h3 id="5-1-堆内存-vs-直接内存"><a href="#5-1-堆内存-vs-直接内存" class="headerlink" title="5.1 堆内存 vs 直接内存"></a>5.1 堆内存 vs 直接内存</h3><table><thead><tr><th>特性</th><th>HeapByteBuffer</th><th>DirectByteBuffer</th></tr></thead><tbody><tr><td>内存位置</td><td>堆内存</td><td>堆外内存</td></tr><tr><td>分配速度</td><td>快</td><td>慢</td></tr><tr><td>访问速度</td><td>相对慢</td><td>相对快</td></tr><tr><td>GC 管理</td><td>是</td><td>否（通过 Cleaner）</td></tr><tr><td>适用场景</td><td>小数据量、频繁创建</td><td>大数据量、长期存在</td></tr></tbody></table><h3 id="5-2-使用建议"><a href="#5-2-使用建议" class="headerlink" title="5.2 使用建议"></a>5.2 使用建议</h3><ol><li><p><strong>选择合适的 Buffer 类型</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 小数据量、临时使用</span>ByteBuffer heapBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 大数据量、需要与操作系统交互</span>ByteBuffer directBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>正确使用 flip() 和 clear()</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 写入数据后准备读取</span>buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 读取完成后准备重新写入</span>buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 部分读取后继续写入</span>buffer<span class="token punctuation">.</span><span class="token function">compact</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>避免频繁创建 Buffer</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不好的做法</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 buffer</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 好的做法：复用 Buffer</span>ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 使用 buffer</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意直接内存的释放</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// DirectByteBuffer 会在 GC 时自动释放</span><span class="token comment" spellcheck="true">// 但可以通过以下方式显式释放（不推荐）</span>DirectBuffer db <span class="token operator">=</span> <span class="token punctuation">(</span>DirectBuffer<span class="token punctuation">)</span> directBuffer<span class="token punctuation">;</span>Cleaner cleaner <span class="token operator">=</span> db<span class="token punctuation">.</span><span class="token function">cleaner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cleaner <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cleaner<span class="token punctuation">.</span><span class="token function">clean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="5-3-常见错误和陷阱"><a href="#5-3-常见错误和陷阱" class="headerlink" title="5.3 常见错误和陷阱"></a>5.3 常见错误和陷阱</h3><ol><li><p><strong>忘记调用 flip()</strong></p><pre class="line-numbers language-java"><code class="language-java">ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 错误：没有调用 flip()，position 在末尾，读取不到数据</span><span class="token keyword">byte</span> b <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 会抛出 BufferUnderflowException</span><span class="token comment" spellcheck="true">// 正确做法</span>buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">byte</span> b <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 正常读取</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>clear() 不会清除数据</strong></p><pre class="line-numbers language-java"><code class="language-java">ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 数据仍然存在，只是 position 和 limit 被重置</span><span class="token comment" spellcheck="true">// 如果需要清除数据，需要手动覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>视图 Buffer 共享数据</strong></p><pre class="line-numbers language-java"><code class="language-java">ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ByteBuffer view <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">duplicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>view<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'h'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 修改视图</span><span class="token comment" spellcheck="true">// 原 buffer 的数据也被修改了</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="6-Buffer-性能优化"><a href="#6-Buffer-性能优化" class="headerlink" title="6. Buffer 性能优化"></a>6. Buffer 性能优化</h2><h3 id="6-1-批量操作"><a href="#6-1-批量操作" class="headerlink" title="6.1 批量操作"></a>6.1 批量操作</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单个操作（慢）</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 批量操作（快）</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span>buffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-2-使用-slice-避免复制"><a href="#6-2-使用-slice-避免复制" class="headerlink" title="6.2 使用 slice() 避免复制"></a>6.2 使用 slice() 避免复制</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 不需要复制数据，创建子 Buffer</span>ByteBuffer subBuffer <span class="token operator">=</span> buffer<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subBuffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subBuffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 操作 subBuffer 不会影响原 buffer 的 position 和 limit</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-3-直接内存的合理使用"><a href="#6-3-直接内存的合理使用" class="headerlink" title="6.3 直接内存的合理使用"></a>6.3 直接内存的合理使用</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于需要与操作系统交互的场景，使用直接内存</span><span class="token comment" spellcheck="true">// 例如：文件 I/O、网络 I/O</span>FileChannel channel <span class="token operator">=</span> FileChannel<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> StandardOpenOption<span class="token punctuation">.</span>READ<span class="token punctuation">)</span><span class="token punctuation">;</span>ByteBuffer directBuffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocateDirect</span><span class="token punctuation">(</span><span class="token number">8192</span><span class="token punctuation">)</span><span class="token punctuation">;</span>channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>directBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-核心要点"><a href="#7-1-核心要点" class="headerlink" title="7.1 核心要点"></a>7.1 核心要点</h3><ol><li><strong>Buffer 的四个核心属性</strong>：capacity、position、limit、mark</li><li><strong>状态转换</strong>：通过 <code>flip()</code>、<code>clear()</code>、<code>rewind()</code>、<code>compact()</code> 等方法切换状态</li><li><strong>两种实现</strong>：<code>HeapByteBuffer</code>（堆内存）和 <code>DirectByteBuffer</code>（直接内存）</li><li><strong>视图机制</strong>：可以创建只读视图、类型视图等，共享底层数据</li></ol><h3 id="7-2-实现原理要点"><a href="#7-2-实现原理要点" class="headerlink" title="7.2 实现原理要点"></a>7.2 实现原理要点</h3><ol><li><strong>HeapByteBuffer</strong>：基于 Java 数组，受 GC 管理，访问速度相对较慢</li><li><strong>DirectByteBuffer</strong>：使用堆外内存，通过 <code>Unsafe</code> 分配，使用 <code>Cleaner</code> 自动释放</li><li><strong>字节序</strong>：影响多字节数据类型的存储和读取顺序</li><li><strong>视图共享</strong>：多个视图 Buffer 共享底层数组，但各自维护独立的 position、limit、mark</li></ol><h3 id="7-3-使用建议"><a href="#7-3-使用建议" class="headerlink" title="7.3 使用建议"></a>7.3 使用建议</h3><ul><li>根据场景选择合适的 Buffer 类型</li><li>正确使用状态转换方法</li><li>避免频繁创建 Buffer，尽量复用</li><li>注意直接内存的使用和释放</li><li>使用批量操作提高性能</li></ul><hr><p><strong>参考资源</strong>：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/Buffer.html">Java NIO Buffer 官方文档</a></li><li><a href="https://jenkov.com/tutorials/java-nio/buffers.html">Java NIO 教程</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是第一篇博客&lt;/p&gt;
&lt;h1 id=&quot;Java-NIO-Buffer-使用与实现原理&quot;&gt;&lt;a href=&quot;#Java-NIO-Buffer-使用与实现原理&quot; class=&quot;headerlink&quot; title=&quot;Java NIO Buffer 使用与实现原理&quot;&gt;&lt;/a&gt;Ja
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringBoot事务实现原理</title>
    <link href="https://zhsongdanc.github.io/posts/104.html"/>
    <id>https://zhsongdanc.github.io/posts/104.html</id>
    <published>2023-10-08T02:30:07.000Z</published>
    <updated>2025-11-21T10:08:20.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-事务机制详解"><a href="#Spring-事务机制详解" class="headerlink" title="Spring 事务机制详解"></a>Spring 事务机制详解</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#1-spring-transactional-实现原理">Spring @Transactional 实现原理</a></li><li><a href="#2-spring-aop-代理机制详解">Spring AOP 代理机制详解</a></li><li><a href="#3-事务传播行为详解">事务传播行为详解</a></li><li><a href="#4-事务隔离级别">事务隔离级别</a></li><li><a href="#5-transactioninterceptor-实现原理">TransactionInterceptor 实现原理</a></li></ol><hr><h2 id="1-Spring-Transactional-实现原理"><a href="#1-Spring-Transactional-实现原理" class="headerlink" title="1. Spring @Transactional 实现原理"></a>1. Spring @Transactional 实现原理</h2><h3 id="1-1-核心机制：AOP（面向切面编程）"><a href="#1-1-核心机制：AOP（面向切面编程）" class="headerlink" title="1.1 核心机制：AOP（面向切面编程）"></a>1.1 核心机制：AOP（面向切面编程）</h3><p><code>@Transactional</code> 基于 Spring AOP，通过代理对象拦截方法调用，在方法执行前后添加事务逻辑。</p><h3 id="1-2-实现流程"><a href="#1-2-实现流程" class="headerlink" title="1.2 实现流程"></a>1.2 实现流程</h3><h4 id="1-2-1-注解扫描与处理"><a href="#1-2-1-注解扫描与处理" class="headerlink" title="1.2.1 注解扫描与处理"></a>1.2.1 注解扫描与处理</h4><p>Spring 在启动时扫描 <code>@Transactional</code>，由 <code>TransactionInterceptor</code> 处理：</p><ul><li><code>@EnableTransactionManagement</code> 启用事务管理</li><li><code>TransactionAttributeSourceAdvisor</code> 识别带 <code>@Transactional</code> 的方法</li><li>创建代理对象（JDK 动态代理或 CGLIB）</li></ul><h4 id="1-2-2-方法拦截执行流程"><a href="#1-2-2-方法拦截执行流程" class="headerlink" title="1.2.2 方法拦截执行流程"></a>1.2.2 方法拦截执行流程</h4><p>当调用带 <code>@Transactional</code> 的方法时：</p><pre><code>1. 代理对象拦截方法调用   ↓2. TransactionInterceptor.invoke()   ↓3. 获取事务属性（传播行为、隔离级别等）   ↓4. 获取或创建事务（PlatformTransactionManager）   ↓5. 执行业务方法   ↓6. 根据执行结果提交或回滚事务</code></pre><h3 id="1-3-关键组件"><a href="#1-3-关键组件" class="headerlink" title="1.3 关键组件"></a>1.3 关键组件</h3><ul><li><strong>TransactionInterceptor</strong>：核心拦截器，负责方法拦截、事务属性解析、事务管理器调用</li><li><strong>PlatformTransactionManager</strong>：事务管理器接口<ul><li><code>DataSourceTransactionManager</code>（JDBC）</li><li><code>HibernateTransactionManager</code>（Hibernate）</li><li><code>JpaTransactionManager</code>（JPA）</li></ul></li><li><strong>TransactionAttributeSource</strong>：解析 <code>@Transactional</code> 属性</li></ul><h3 id="1-4-注意事项"><a href="#1-4-注意事项" class="headerlink" title="1.4 注意事项"></a>1.4 注意事项</h3><h4 id="代理失效场景"><a href="#代理失效场景" class="headerlink" title="代理失效场景"></a>代理失效场景</h4><ul><li>同一个类内部方法调用（绕过代理）</li><li>方法不是 public</li><li>异常被捕获未抛出</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ❌ 错误示例：内部调用不会触发事务</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不会走代理</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 事务不会生效</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// ✅ 正确：通过注入的代理对象调用</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> UserService self<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注入代理对象</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        self<span class="token punctuation">.</span><span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 会走代理，事务生效</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 事务生效</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="2-Spring-AOP-代理机制详解"><a href="#2-Spring-AOP-代理机制详解" class="headerlink" title="2. Spring AOP 代理机制详解"></a>2. Spring AOP 代理机制详解</h2><h3 id="2-1-Spring-AOP-与-AspectJ-的关系"><a href="#2-1-Spring-AOP-与-AspectJ-的关系" class="headerlink" title="2.1 Spring AOP 与 AspectJ 的关系"></a>2.1 Spring AOP 与 AspectJ 的关系</h3><h4 id="2-1-1-核心区别"><a href="#2-1-1-核心区别" class="headerlink" title="2.1.1 核心区别"></a>2.1.1 核心区别</h4><p><strong>Spring AOP 和 AspectJ 不是同一级别的</strong>，它们是两种不同的 AOP 实现方式：</p><pre><code>AOP 实现方式（顶层）    ├── Spring AOP（一种实现方式）    │   └── 使用代理模式    │       ├── JDK 动态代理    │       └── CGLIB 代理    │    └── AspectJ（另一种实现方式）        └── 使用字节码织入（不是代理）            ├── 编译时织入            ├── 编译后织入            └── 加载时织入（LTW）</code></pre><h4 id="2-1-2-Spring-AOP：运行时动态代理"><a href="#2-1-2-Spring-AOP：运行时动态代理" class="headerlink" title="2.1.2 Spring AOP：运行时动态代理"></a>2.1.2 Spring AOP：运行时动态代理</h4><p><strong>实现方式</strong>：</p><ul><li><strong>JDK 动态代理</strong>：基于接口，使用 <code>java.lang.reflect.Proxy</code></li><li><strong>CGLIB 代理</strong>：基于子类继承，运行时生成字节码</li></ul><p><strong>特点</strong>：</p><ul><li>在运行时生成代理对象</li><li>仅支持方法级别的拦截</li><li>仅支持 Spring Bean</li></ul><h4 id="2-1-3-AspectJ：编译时-加载时织入（不是动态代理）"><a href="#2-1-3-AspectJ：编译时-加载时织入（不是动态代理）" class="headerlink" title="2.1.3 AspectJ：编译时/加载时织入（不是动态代理）"></a>2.1.3 AspectJ：编译时/加载时织入（不是动态代理）</h4><p><strong>织入时机</strong>：</p><ul><li><strong>编译时织入</strong>：编译时修改字节码</li><li><strong>编译后织入</strong>：对已编译的 .class 文件进行织入</li><li><strong>加载时织入</strong>：类加载时通过 ClassLoader 织入</li></ul><p><strong>特点</strong>：</p><ul><li>不是动态代理，而是字节码织入</li><li>支持字段、构造器、静态初始化等</li><li>支持任意 Java 类</li></ul><h4 id="2-1-4-对比总结"><a href="#2-1-4-对比总结" class="headerlink" title="2.1.4 对比总结"></a>2.1.4 对比总结</h4><table><thead><tr><th>特性</th><th>Spring AOP</th><th>AspectJ</th></tr></thead><tbody><tr><td>实现方式</td><td>动态代理（运行时）</td><td>字节码织入</td></tr><tr><td>织入时机</td><td>运行时</td><td>编译时/编译后/加载时</td></tr><tr><td>性能</td><td>相对较慢（代理调用）</td><td>更快（直接执行）</td></tr><tr><td>功能范围</td><td>仅方法级别</td><td>字段、构造器、静态初始化等</td></tr><tr><td>依赖</td><td>仅 Spring 容器</td><td>需要 AspectJ 编译器/Weaver</td></tr><tr><td>限制</td><td>仅 Spring Bean</td><td>任意 Java 类</td></tr></tbody></table><h4 id="2-1-5-Spring-中使用-AspectJ-的方式"><a href="#2-1-5-Spring-中使用-AspectJ-的方式" class="headerlink" title="2.1.5 Spring 中使用 AspectJ 的方式"></a>2.1.5 Spring 中使用 AspectJ 的方式</h4><p><strong>方式一：Spring AOP（默认，运行时代理）</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用 AspectJ 注解风格，但底层是 Spring AOP</span><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyAspect</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"execution(* com.example.*.*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>需要 <code>@EnableAspectJAutoProxy</code></li><li>运行时动态代理</li><li>仅支持 Spring Bean</li></ul><p><strong>方式二：AspectJ LTW（加载时织入）</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需要配置 aop.xml</span><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableLoadTimeWeaving</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AspectJConfig</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>需要 <code>aspectjweaver.jar</code></li><li>类加载时织入</li><li>支持任意 Java 类</li></ul><h3 id="2-2-CGLIB-与-AspectJ-在-Spring-中的配合"><a href="#2-2-CGLIB-与-AspectJ-在-Spring-中的配合" class="headerlink" title="2.2 CGLIB 与 AspectJ 在 Spring 中的配合"></a>2.2 CGLIB 与 AspectJ 在 Spring 中的配合</h3><h4 id="2-2-1-核心关系总结"><a href="#2-2-1-核心关系总结" class="headerlink" title="2.2.1 核心关系总结"></a>2.2.1 核心关系总结</h4><ul><li><strong>CGLIB 和 AspectJ 是两种不同的技术</strong>，用于不同的目的</li><li><strong>Spring AOP 使用 CGLIB 作为代理实现方式之一</strong></li><li><strong>AspectJ 提供切点表达式解析</strong>，Spring AOP 借用其注解风格</li></ul><h4 id="2-2-2-CGLIB-是什么"><a href="#2-2-2-CGLIB-是什么" class="headerlink" title="2.2.2 CGLIB 是什么"></a>2.2.2 CGLIB 是什么</h4><p>CGLIB（Code Generation Library）是一个字节码生成库，用于在运行时生成类的子类。</p><p><strong>特点</strong>：</p><ul><li>运行时生成代理类（字节码生成）</li><li>基于继承（创建目标类的子类）</li><li>不需要接口</li><li>性能较好（比 JDK 动态代理快）</li></ul><p><strong>工作原理</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 原始类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// CGLIB 生成的代理类（运行时生成）</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span>$$EnhancerByCGLIB$$xxx <span class="token keyword">extends</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> MethodInterceptor interceptor<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 调用拦截器</span>        interceptor<span class="token punctuation">.</span><span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> method<span class="token punctuation">,</span> args<span class="token punctuation">,</span> methodProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-AspectJ-在-Spring-中的作用"><a href="#2-2-3-AspectJ-在-Spring-中的作用" class="headerlink" title="2.2.3 AspectJ 在 Spring 中的作用"></a>2.2.3 AspectJ 在 Spring 中的作用</h4><p>AspectJ 在 Spring AOP 中提供：</p><ul><li>切点表达式语言（<code>execution</code>, <code>within</code> 等）</li><li>注解支持（<code>@Aspect</code>, <code>@Before</code>, <code>@After</code> 等）</li><li>表达式解析器（<code>aspectjweaver.jar</code>）</li></ul><h4 id="2-2-4-在-Spring-中的完整关系"><a href="#2-2-4-在-Spring-中的完整关系" class="headerlink" title="2.2.4 在 Spring 中的完整关系"></a>2.2.4 在 Spring 中的完整关系</h4><pre><code>Spring AOP    ├── 使用 AspectJ 的注解风格 (@Aspect, @Before, @After...)    ├── 使用 AspectJ 的切点表达式 (execution, within...)    ├── 使用 AspectJ 的解析器 (aspectjweaver.jar)    └── 使用两种代理实现：        ├── JDK 动态代理 (基于接口)        └── CGLIB 代理 (基于继承) ← 这里用到 CGLIB</code></pre><p><strong>简单记忆</strong>：</p><ul><li><strong>AspectJ</strong>：提供语法和解析器（告诉 Spring 切哪里）</li><li><strong>CGLIB</strong>：生成代理类（告诉 Spring 怎么切）</li></ul><p>两者在 Spring AOP 中配合使用，但职责不同。</p><h3 id="2-3-代理类的生成时机"><a href="#2-3-代理类的生成时机" class="headerlink" title="2.3 代理类的生成时机"></a>2.3 代理类的生成时机</h3><h4 id="2-3-1-核心答案"><a href="#2-3-1-核心答案" class="headerlink" title="2.3.1 核心答案"></a>2.3.1 核心答案</h4><p><strong>代理类在 Spring 启动时（Bean 创建时）生成，不是在实际调用时生成</strong></p><h4 id="2-3-2-详细流程"><a href="#2-3-2-详细流程" class="headerlink" title="2.3.2 详细流程"></a>2.3.2 详细流程</h4><p><strong>阶段1：Spring 启动时（Bean 创建阶段）</strong></p><pre><code>1. 扫描所有 @Component、@Service 等注解的类   ↓2. 识别带 @Transactional 的类和方法   ↓3. 创建 Bean 定义（BeanDefinition）   ↓4. 检查是否需要代理   ↓5. 创建代理对象（此时就生成了！）   ↓6. 将代理对象放入容器</code></pre><p><strong>阶段2：实际调用时（运行时）</strong></p><pre><code>1. 从容器获取 Bean（已经是代理对象了！）   ↓2. 调用方法   ↓3. 代理对象拦截调用   ↓4. TransactionInterceptor 处理</code></pre><h4 id="2-3-3-完整时序图"><a href="#2-3-3-完整时序图" class="headerlink" title="2.3.3 完整时序图"></a>2.3.3 完整时序图</h4><pre><code>Spring 启动阶段（Bean 创建时）│├─ 1. 扫描所有 Bean│   └─ 发现 @Service class UserService│├─ 2. 检查是否需要代理│   └─ 发现 @Transactional 注解│├─ 3. 创建代理对象（此时生成！）│   ├─ 使用 CGLIB 或 JDK 动态代理│   ├─ 生成：UserService$$EnhancerBySpringCGLIB$$xxx│   └─ 添加 TransactionInterceptor│└─ 4. 将代理对象放入容器    └─ 容器中存储的是代理对象，不是原始对象─────────────────────────────────────────运行时（实际调用时）│├─ 1. 从容器获取 Bean│   └─ 返回的是代理对象（已存在）│├─ 2. 调用方法│   └─ userService.saveUser(user)│├─ 3. 代理对象拦截│   └─ UserService$$EnhancerBySpringCGLIB$$xxx.saveUser()│├─ 4. TransactionInterceptor.invoke()│   ├─ 获取事务属性│   ├─ 创建/获取事务│   ├─ 调用原始方法│   └─ 提交/回滚事务│└─ 5. 返回结果</code></pre><h4 id="2-3-4-代理类命名规则"><a href="#2-3-4-代理类命名规则" class="headerlink" title="2.3.4 代理类命名规则"></a>2.3.4 代理类命名规则</h4><p><strong>JDK 动态代理</strong>：</p><pre class="line-numbers language-java"><code class="language-java">$Proxy0$Proxy1$Proxy2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>CGLIB 代理</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// CGLIB 代理生成的类名格式</span>原始类名$$EnhancerByCGLIB$$hashcode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>Spring AOP 使用 CGLIB</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Spring AOP 使用 CGLIB 时的类名格式</span>原始类名$$EnhancerBySpringCGLIB$$hashcode<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-3-5-关键点总结"><a href="#2-3-5-关键点总结" class="headerlink" title="2.3.5 关键点总结"></a>2.3.5 关键点总结</h4><ul><li><strong>代理对象生成时机</strong>：Spring 启动时（Bean 创建阶段）</li><li><strong>不是在调用时生成</strong>：调用时只是使用已存在的代理对象</li><li><strong>为什么在启动时生成</strong>：<ul><li>性能：避免每次调用都创建代理</li><li>一致性：同一个 Bean 始终使用同一个代理对象</li><li>容器管理：代理对象作为 Bean 被 Spring 管理</li></ul></li></ul><hr><h2 id="3-事务传播行为详解"><a href="#3-事务传播行为详解" class="headerlink" title="3. 事务传播行为详解"></a>3. 事务传播行为详解</h2><h3 id="3-1-最常用的三个传播行为"><a href="#3-1-最常用的三个传播行为" class="headerlink" title="3.1 最常用的三个传播行为"></a>3.1 最常用的三个传播行为</h3><h4 id="1-REQUIRED（默认，最常用）"><a href="#1-REQUIRED（默认，最常用）" class="headerlink" title="1. REQUIRED（默认，最常用）"></a>1. REQUIRED（默认，最常用）</h4><p><strong>含义</strong>：</p><ul><li>如果当前存在事务，则加入该事务</li><li>如果当前不存在事务，则创建一个新事务</li></ul><p><strong>使用场景</strong>：</p><ul><li>大多数业务方法</li><li>默认行为，无需显式指定</li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> OrderService orderService<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 默认就是 REQUIRED，可以不写</span>    <span class="token annotation punctuation">@Transactional</span>  <span class="token comment" spellcheck="true">// 等同于 @Transactional(propagation = Propagation.REQUIRED)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createUserAndOrder</span><span class="token punctuation">(</span>User user<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 创建用户</span>        userMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用另一个事务方法</span>        orderService<span class="token punctuation">.</span><span class="token function">createOrder</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 会加入当前事务</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createOrder</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果从 createUserAndOrder 调用，会加入外层事务</span>        <span class="token comment" spellcheck="true">// 如果单独调用，会创建新事务</span>        orderMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Order</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-REQUIRES-NEW（第二常用）"><a href="#2-REQUIRES-NEW（第二常用）" class="headerlink" title="2. REQUIRES_NEW（第二常用）"></a>2. REQUIRES_NEW（第二常用）</h4><p><strong>含义</strong>：</p><ul><li>总是创建一个新事务</li><li>如果当前存在事务，则挂起当前事务，创建新事务</li><li>新事务独立提交或回滚</li></ul><p><strong>使用场景</strong>：</p><ul><li>日志记录（即使主业务失败也要记录）</li><li>审计操作</li><li>需要独立事务的业务</li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> LogService logService<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createOrder</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 主业务逻辑</span>            orderMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 记录日志（需要独立事务）</span>            logService<span class="token punctuation">.</span><span class="token function">saveLog</span><span class="token punctuation">(</span><span class="token string">"订单创建成功"</span><span class="token punctuation">,</span> order<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 即使这里回滚，日志也会保存</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LogService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 使用 REQUIRES_NEW，确保日志总是被保存</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">saveLog</span><span class="token punctuation">(</span>String message<span class="token punctuation">,</span> Long orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 这个操作会在新事务中执行</span>        <span class="token comment" spellcheck="true">// 即使外层事务回滚，这个也会提交</span>        logMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Log</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> orderId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-NESTED（第三常用）"><a href="#3-NESTED（第三常用）" class="headerlink" title="3. NESTED（第三常用）"></a>3. NESTED（第三常用）</h4><p><strong>含义</strong>：</p><ul><li>如果当前存在事务，则创建一个嵌套事务（保存点）</li><li>如果当前不存在事务，则创建一个新事务</li><li>嵌套事务可以独立回滚，不影响外层事务</li></ul><p><strong>使用场景</strong>：</p><ul><li>批量操作中的单个失败处理</li><li>需要部分回滚的场景</li><li>子操作失败不影响主操作</li></ul><p><strong>代码示例</strong>：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BatchService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">batchProcessOrders</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Order<span class="token operator">></span> orders<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Order order <span class="token operator">:</span> orders<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 每个订单处理是嵌套事务</span>                <span class="token function">processSingleOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 单个订单失败不影响其他订单</span>                log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"订单处理失败: "</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 嵌套事务回滚，外层事务继续</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用 NESTED，创建嵌套事务（保存点）</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">processSingleOrder</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 验证订单</span>        <span class="token function">validateOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 扣减库存</span>        <span class="token function">reduceStock</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建订单</span>        orderMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果这里抛异常，只回滚这个嵌套事务</span>        <span class="token comment" spellcheck="true">// 不影响 batchProcessOrders 中的其他订单</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-三个传播行为对比"><a href="#3-2-三个传播行为对比" class="headerlink" title="3.2 三个传播行为对比"></a>3.2 三个传播行为对比</h3><table><thead><tr><th>传播行为</th><th>当前有事务</th><th>当前无事务</th><th>回滚影响</th><th>使用频率</th></tr></thead><tbody><tr><td><strong>REQUIRED</strong></td><td>加入事务</td><td>创建新事务</td><td>一起回滚</td><td>⭐⭐⭐⭐⭐</td></tr><tr><td><strong>REQUIRES_NEW</strong></td><td>挂起，创建新事务</td><td>创建新事务</td><td>独立回滚</td><td>⭐⭐⭐⭐</td></tr><tr><td><strong>NESTED</strong></td><td>创建嵌套事务</td><td>创建新事务</td><td>可独立回滚</td><td>⭐⭐⭐</td></tr></tbody></table><h3 id="3-3-REQUIRES-NEW-和-NESTED-的区别"><a href="#3-3-REQUIRES-NEW-和-NESTED-的区别" class="headerlink" title="3.3 REQUIRES_NEW 和 NESTED 的区别"></a>3.3 REQUIRES_NEW 和 NESTED 的区别</h3><h4 id="REQUIRES-NEW：互不影响（完全独立）"><a href="#REQUIRES-NEW：互不影响（完全独立）" class="headerlink" title="REQUIRES_NEW：互不影响（完全独立）"></a>REQUIRES_NEW：互不影响（完全独立）</h4><ul><li>创建完全独立的新事务</li><li>外层事务回滚 → 不影响内层（内层已独立提交）</li><li>内层事务回滚 → 不影响外层（外层继续执行）</li></ul><h4 id="NESTED：有影响（单向）"><a href="#NESTED：有影响（单向）" class="headerlink" title="NESTED：有影响（单向）"></a>NESTED：有影响（单向）</h4><ul><li>创建嵌套事务（保存点）</li><li>外层回滚 → 影响内层（一起回滚）</li><li>内层回滚 → 不影响外层（回滚到保存点）</li></ul><p><strong>对比表格</strong>：</p><table><thead><tr><th>特性</th><th>REQUIRES_NEW</th><th>NESTED</th></tr></thead><tbody><tr><td>事务关系</td><td>完全独立</td><td>嵌套（保存点）</td></tr><tr><td>外层回滚影响内层</td><td>❌ 不影响（内层已提交）</td><td>✅ 影响（一起回滚）</td></tr><tr><td>内层回滚影响外层</td><td>❌ 不影响（外层继续）</td><td>❌ 不影响（回滚到保存点）</td></tr><tr><td>提交时机</td><td>内层立即提交</td><td>外层提交时一起提交</td></tr><tr><td>使用场景</td><td>日志、审计（必须保存）</td><td>批量操作（部分回滚）</td></tr></tbody></table><hr><h2 id="4-事务隔离级别"><a href="#4-事务隔离级别" class="headerlink" title="4. 事务隔离级别"></a>4. 事务隔离级别</h2><h3 id="4-1-可以设置不同的隔离级别"><a href="#4-1-可以设置不同的隔离级别" class="headerlink" title="4.1 可以设置不同的隔离级别"></a>4.1 可以设置不同的隔离级别</h3><p>每个 <code>@Transactional</code> 注解都可以独立配置自己的隔离级别，互不影响。</p><h3 id="4-2-如何设置不同的隔离级别"><a href="#4-2-如何设置不同的隔离级别" class="headerlink" title="4.2 如何设置不同的隔离级别"></a>4.2 如何设置不同的隔离级别</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 方法1：使用默认隔离级别（通常是 READ_COMMITTED）</span>    <span class="token annotation punctuation">@Transactional</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createOrder</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        orderMapper<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 方法2：使用 READ_UNCOMMITTED（最低隔离级别，性能最好）</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>isolation <span class="token operator">=</span> Isolation<span class="token punctuation">.</span>READ_UNCOMMITTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quickQuery</span><span class="token punctuation">(</span>Long orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> orderMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 方法3：使用 READ_COMMITTED（默认，大多数场景）</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>isolation <span class="token operator">=</span> Isolation<span class="token punctuation">.</span>READ_COMMITTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateOrder</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span> <span class="token punctuation">{</span>        orderMapper<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 方法4：使用 REPEATABLE_READ（可重复读）</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>isolation <span class="token operator">=</span> Isolation<span class="token punctuation">.</span>REPEATABLE_READ<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">calculateTotalAmount</span><span class="token punctuation">(</span>Long userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 需要多次读取一致性的场景</span>        List<span class="token operator">&lt;</span>Order<span class="token operator">></span> orders <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">selectByUserId</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>        BigDecimal total <span class="token operator">=</span> orders<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Order<span class="token operator">:</span><span class="token operator">:</span>getAmount<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>BigDecimal<span class="token punctuation">.</span>ZERO<span class="token punctuation">,</span> BigDecimal<span class="token operator">:</span><span class="token operator">:</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> total<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 方法5：使用 SERIALIZABLE（最高隔离级别，最严格）</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>isolation <span class="token operator">=</span> Isolation<span class="token punctuation">.</span>SERIALIZABLE<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">criticalBalanceUpdate</span><span class="token punctuation">(</span>Long accountId<span class="token punctuation">,</span> BigDecimal amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 关键业务，需要最高级别的隔离</span>        Account account <span class="token operator">=</span> accountMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>accountId<span class="token punctuation">)</span><span class="token punctuation">;</span>        account<span class="token punctuation">.</span><span class="token function">setBalance</span><span class="token punctuation">(</span>account<span class="token punctuation">.</span><span class="token function">getBalance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        accountMapper<span class="token punctuation">.</span><span class="token function">updateById</span><span class="token punctuation">(</span>account<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-五种隔离级别"><a href="#4-3-五种隔离级别" class="headerlink" title="4.3 五种隔离级别"></a>4.3 五种隔离级别</h3><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>性能</th><th>使用场景</th></tr></thead><tbody><tr><td><strong>READ_UNCOMMITTED</strong></td><td>❌ 可能</td><td>❌ 可能</td><td>❌ 可能</td><td>⭐⭐⭐⭐⭐</td><td>统计查询、性能优先</td></tr><tr><td><strong>READ_COMMITTED</strong></td><td>✅ 避免</td><td>❌ 可能</td><td>❌ 可能</td><td>⭐⭐⭐⭐</td><td>大多数业务（默认）</td></tr><tr><td><strong>REPEATABLE_READ</strong></td><td>✅ 避免</td><td>✅ 避免</td><td>❌ 可能</td><td>⭐⭐⭐</td><td>需要多次读取一致</td></tr><tr><td><strong>SERIALIZABLE</strong></td><td>✅ 避免</td><td>✅ 避免</td><td>✅ 避免</td><td>⭐</td><td>关键业务、金融操作</td></tr></tbody></table><h3 id="4-4-隔离级别的实现原理"><a href="#4-4-隔离级别的实现原理" class="headerlink" title="4.4 隔离级别的实现原理"></a>4.4 隔离级别的实现原理</h3><p>虽然数据库有全局隔离级别，但 Spring 可以在每个事务连接上设置不同的隔离级别：</p><pre><code>Spring 事务管理器的工作流程1. 开启事务时，从连接池获取 Connection   ↓2. 为这个 Connection 设置隔离级别   Connection.setTransactionIsolation(Isolation.REPEATABLE_READ)   ↓3. 执行业务方法   ↓4. 提交/回滚事务   ↓5. 归还 Connection 到连接池   （隔离级别会重置为连接池的默认值）</code></pre><p><strong>关键点</strong>：</p><ul><li>每个事务使用独立的数据库连接</li><li>Spring 在事务开始时为连接设置隔离级别</li><li>通过 <code>Connection.setTransactionIsolation()</code> 实现</li><li>事务结束后连接归还连接池</li></ul><h3 id="4-5-注意事项"><a href="#4-5-注意事项" class="headerlink" title="4.5 注意事项"></a>4.5 注意事项</h3><ol><li><strong>隔离级别不能降级</strong>：内层事务不能使用比外层更低的隔离级别</li><li><strong>数据库支持情况</strong>：不同数据库支持的隔离级别不同</li><li><strong>性能考虑</strong>：根据业务需求选择合适的隔离级别</li></ol><hr><h2 id="5-TransactionInterceptor-实现原理"><a href="#5-TransactionInterceptor-实现原理" class="headerlink" title="5. TransactionInterceptor 实现原理"></a>5. TransactionInterceptor 实现原理</h2><h3 id="5-1-TransactionInterceptor-入口"><a href="#5-1-TransactionInterceptor-入口" class="headerlink" title="5.1 TransactionInterceptor 入口"></a>5.1 TransactionInterceptor 入口</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Spring 源码：TransactionInterceptor</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TransactionInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> PlatformTransactionManager transactionManager<span class="token punctuation">;</span>    <span class="token keyword">private</span> TransactionAttributeSource transactionAttributeSource<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>MethodInvocation invocation<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. 获取目标类和方法</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> targetClass <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">?</span>             AopUtils<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span>invocation<span class="token punctuation">.</span><span class="token function">getThis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>        Method method <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 获取事务属性（从 @Transactional 注解解析）</span>        TransactionAttribute txAttr <span class="token operator">=</span>             transactionAttributeSource<span class="token punctuation">.</span><span class="token function">getTransactionAttribute</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. 获取事务管理器</span>        PlatformTransactionManager tm <span class="token operator">=</span> <span class="token function">determineTransactionManager</span><span class="token punctuation">(</span>txAttr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4. 创建事务信息（关键：这里处理传播行为）</span>        TransactionInfo txInfo <span class="token operator">=</span> <span class="token function">createTransactionIfNecessary</span><span class="token punctuation">(</span>tm<span class="token punctuation">,</span> txAttr<span class="token punctuation">,</span> method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>        Object retVal<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 5. 执行业务方法</span>            retVal <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6. 提交事务</span>            <span class="token function">commitTransactionAfterReturning</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> retVal<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 7. 回滚事务</span>            <span class="token function">completeTransactionAfterThrowing</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 8. 清理事务信息</span>            <span class="token function">cleanupTransactionInfo</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-PlatformTransactionManager-获取事务（处理传播行为）"><a href="#5-2-PlatformTransactionManager-获取事务（处理传播行为）" class="headerlink" title="5.2 PlatformTransactionManager 获取事务（处理传播行为）"></a>5.2 PlatformTransactionManager 获取事务（处理传播行为）</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Spring 源码：AbstractPlatformTransactionManager</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractPlatformTransactionManager</span>         <span class="token keyword">implements</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> TransactionStatus <span class="token function">getTransaction</span><span class="token punctuation">(</span>TransactionDefinition definition<span class="token punctuation">)</span>             <span class="token keyword">throws</span> TransactionException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. 获取当前事务（可能为 null）</span>        Object transaction <span class="token operator">=</span> <span class="token function">doGetTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 检查当前是否存在事务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isExistingTransaction</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 处理已存在事务的情况（根据传播行为）</span>            <span class="token keyword">return</span> <span class="token function">handleExistingTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 3. 当前不存在事务，需要创建新事务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>definition<span class="token punctuation">.</span><span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span>                 TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRED <span class="token operator">||</span>               definition<span class="token punctuation">.</span><span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span>                 TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRES_NEW <span class="token operator">||</span>               definition<span class="token punctuation">.</span><span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span>                 TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_NESTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 挂起当前事务（如果有）</span>            SuspendedResourcesHolder suspendedResources <span class="token operator">=</span> <span class="token function">suspend</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 创建新事务</span>                <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span>                     suspendedResources<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resume</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> suspendedResources<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 处理已存在事务的情况（关键方法）</span>    <span class="token keyword">private</span> TransactionStatus <span class="token function">handleExistingTransaction</span><span class="token punctuation">(</span>            TransactionDefinition definition<span class="token punctuation">,</span>             Object transaction<span class="token punctuation">,</span>             <span class="token keyword">boolean</span> debugEnabled<span class="token punctuation">)</span> <span class="token keyword">throws</span> TransactionException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// PROPAGATION_REQUIRES_NEW：挂起当前事务，创建新事务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>definition<span class="token punctuation">.</span><span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span>                 TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_REQUIRES_NEW<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 挂起当前事务</span>            SuspendedResourcesHolder suspendedResources <span class="token operator">=</span> <span class="token function">suspend</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 创建新事务</span>                <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span>                     suspendedResources<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error beginEx<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">resumeAfterBeginException</span><span class="token punctuation">(</span>transaction<span class="token punctuation">,</span> suspendedResources<span class="token punctuation">,</span> beginEx<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">throw</span> beginEx<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// PROPAGATION_NESTED：创建嵌套事务（保存点）</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>definition<span class="token punctuation">.</span><span class="token function">getPropagationBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span>                 TransactionDefinition<span class="token punctuation">.</span>PROPAGATION_NESTED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isNestedTransactionAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NestedTransactionNotSupportedException</span><span class="token punctuation">(</span>                    <span class="token string">"Transaction manager does not allow nested transactions"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 创建保存点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">useSavepointForNestedTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                DefaultTransactionStatus status <span class="token operator">=</span> <span class="token function">prepareTransactionStatus</span><span class="token punctuation">(</span>                    definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                status<span class="token punctuation">.</span><span class="token function">createAndHoldSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> status<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// PROPAGATION_REQUIRED：加入当前事务</span>        <span class="token comment" spellcheck="true">// 验证隔离级别（不能降级）</span>        <span class="token function">validateExistingTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 加入当前事务，不创建新事务</span>        <span class="token keyword">return</span> <span class="token function">prepareTransactionStatus</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span>             debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">,</span> newSynchronization<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-具体传播行为的实现"><a href="#5-3-具体传播行为的实现" class="headerlink" title="5.3 具体传播行为的实现"></a>5.3 具体传播行为的实现</h3><h4 id="5-3-1-REQUIRED（默认）的实现"><a href="#5-3-1-REQUIRED（默认）的实现" class="headerlink" title="5.3.1 REQUIRED（默认）的实现"></a>5.3.1 REQUIRED（默认）的实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// REQUIRED 传播行为的处理逻辑</span><span class="token keyword">private</span> TransactionStatus <span class="token function">handleRequired</span><span class="token punctuation">(</span>        TransactionDefinition definition<span class="token punctuation">,</span>         Object transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前存在事务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isExistingTransaction</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 加入当前事务（不创建新事务）</span>        <span class="token function">validateExistingTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">prepareTransactionStatus</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span>             debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">,</span> newSynchronization<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前不存在事务，创建新事务</span>    <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-2-REQUIRES-NEW-的实现"><a href="#5-3-2-REQUIRES-NEW-的实现" class="headerlink" title="5.3.2 REQUIRES_NEW 的实现"></a>5.3.2 REQUIRES_NEW 的实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// REQUIRES_NEW 传播行为的处理逻辑</span><span class="token keyword">private</span> TransactionStatus <span class="token function">handleRequiresNew</span><span class="token punctuation">(</span>        TransactionDefinition definition<span class="token punctuation">,</span>         Object transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果当前存在事务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isExistingTransaction</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. 挂起当前事务</span>        SuspendedResourcesHolder suspendedResources <span class="token operator">=</span> <span class="token function">suspend</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 2. 创建新事务（独立事务）</span>            <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span>                 suspendedResources<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> Error beginEx<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果创建新事务失败，恢复被挂起的事务</span>            <span class="token function">resumeAfterBeginException</span><span class="token punctuation">(</span>transaction<span class="token punctuation">,</span> suspendedResources<span class="token punctuation">,</span> beginEx<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> beginEx<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前不存在事务，直接创建新事务</span>    <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 挂起当前事务</span><span class="token keyword">protected</span> <span class="token keyword">final</span> SuspendedResourcesHolder <span class="token function">suspend</span><span class="token punctuation">(</span>Object transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 保存当前事务的所有信息</span>    <span class="token comment" spellcheck="true">// 清理当前线程的事务信息</span>    <span class="token comment" spellcheck="true">// 返回被挂起的事务信息</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 恢复被挂起的事务</span><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">resume</span><span class="token punctuation">(</span>Object transaction<span class="token punctuation">,</span>         SuspendedResourcesHolder resourcesHolder<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 恢复被挂起的事务信息</span>    <span class="token comment" spellcheck="true">// 重新设置到当前线程</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-3-NESTED-的实现"><a href="#5-3-3-NESTED-的实现" class="headerlink" title="5.3.3 NESTED 的实现"></a>5.3.3 NESTED 的实现</h4><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// NESTED 传播行为的处理逻辑</span><span class="token keyword">private</span> TransactionStatus <span class="token function">handleNested</span><span class="token punctuation">(</span>        TransactionDefinition definition<span class="token punctuation">,</span>         Object transaction<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 检查是否支持嵌套事务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isNestedTransactionAllowed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NestedTransactionNotSupportedException</span><span class="token punctuation">(</span>            <span class="token string">"Transaction manager does not allow nested transactions"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前存在事务</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isExistingTransaction</span><span class="token punctuation">(</span>transaction<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用保存点（Savepoint）实现嵌套事务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">useSavepointForNestedTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建保存点</span>            DefaultTransactionStatus status <span class="token operator">=</span> <span class="token function">prepareTransactionStatus</span><span class="token punctuation">(</span>                definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 创建并持有保存点</span>            status<span class="token punctuation">.</span><span class="token function">createAndHoldSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> status<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 某些事务管理器不支持保存点，创建新事务</span>            <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 如果当前不存在事务，创建新事务</span>    <span class="token keyword">return</span> <span class="token function">startTransaction</span><span class="token punctuation">(</span>definition<span class="token punctuation">,</span> transaction<span class="token punctuation">,</span> debugEnabled<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 创建保存点（DataSourceTransactionManager 实现）</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doSetSavepoint</span><span class="token punctuation">(</span>Object savepoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> TransactionException <span class="token punctuation">{</span>    ConnectionHolder conHolder <span class="token operator">=</span> <span class="token punctuation">(</span>ConnectionHolder<span class="token punctuation">)</span>         TransactionSynchronizationManager<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token function">obtainDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 在数据库连接上创建保存点</span>        Savepoint savepointToUse <span class="token operator">=</span> conHolder<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">setSavepoint</span><span class="token punctuation">(</span>savepointName<span class="token punctuation">)</span><span class="token punctuation">;</span>        conHolder<span class="token punctuation">.</span><span class="token function">setSavepoint</span><span class="token punctuation">(</span>savepointToUse<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CannotCreateTransactionException</span><span class="token punctuation">(</span>            <span class="token string">"Could not create JDBC savepoint"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 回滚到保存点</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRollbackToSavepoint</span><span class="token punctuation">(</span>Object savepoint<span class="token punctuation">)</span> <span class="token keyword">throws</span> TransactionException <span class="token punctuation">{</span>    ConnectionHolder conHolder <span class="token operator">=</span> <span class="token punctuation">(</span>ConnectionHolder<span class="token punctuation">)</span>         TransactionSynchronizationManager<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token function">obtainDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 回滚到保存点</span>        conHolder<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Savepoint<span class="token punctuation">)</span> savepoint<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TransactionSystemException</span><span class="token punctuation">(</span>            <span class="token string">"Could not roll back to JDBC savepoint"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-事务提交和回滚的处理"><a href="#5-4-事务提交和回滚的处理" class="headerlink" title="5.4 事务提交和回滚的处理"></a>5.4 事务提交和回滚的处理</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 提交事务</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">commitTransactionAfterReturning</span><span class="token punctuation">(</span>TransactionInfo txInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>txInfo <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> txInfo<span class="token punctuation">.</span><span class="token function">hasTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 提交事务</span>        txInfo<span class="token punctuation">.</span><span class="token function">getTransactionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">.</span><span class="token function">getTransactionStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractPlatformTransactionManager 的提交逻辑</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span>TransactionStatus status<span class="token punctuation">)</span> <span class="token keyword">throws</span> TransactionException <span class="token punctuation">{</span>    DefaultTransactionStatus defStatus <span class="token operator">=</span> <span class="token punctuation">(</span>DefaultTransactionStatus<span class="token punctuation">)</span> status<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果是嵌套事务（有保存点）</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>defStatus<span class="token punctuation">.</span><span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 只释放保存点，不提交外层事务</span>        status<span class="token punctuation">.</span><span class="token function">releaseHeldSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 如果是新事务（REQUIRES_NEW 或独立事务）</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 提交事务</span>        <span class="token function">doCommit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 如果是加入的事务（REQUIRED），不提交，等待外层提交</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 不提交，外层事务提交时会一起提交</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-完整执行流程示例"><a href="#5-5-完整执行流程示例" class="headerlink" title="5.5 完整执行流程示例"></a>5.5 完整执行流程示例</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. TransactionInterceptor.invoke()</span>        <span class="token comment" spellcheck="true">// 2. createTransactionIfNecessary()</span>        <span class="token comment" spellcheck="true">// 3. tm.getTransaction() -> handleExistingTransaction()</span>        <span class="token comment" spellcheck="true">//    -> 当前无事务，创建新事务</span>        <span class="token comment" spellcheck="true">// 4. 执行业务代码</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 REQUIRES_NEW</span>        <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用 NESTED</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. TransactionInterceptor.invoke()</span>        <span class="token comment" spellcheck="true">// 2. createTransactionIfNecessary()</span>        <span class="token comment" spellcheck="true">// 3. tm.getTransaction() -> handleExistingTransaction()</span>        <span class="token comment" spellcheck="true">//    -> 检测到当前有事务</span>        <span class="token comment" spellcheck="true">//    -> suspend(transaction) 挂起外层事务</span>        <span class="token comment" spellcheck="true">//    -> startTransaction() 创建新事务</span>        <span class="token comment" spellcheck="true">// 4. 执行业务代码</span>        <span class="token comment" spellcheck="true">// 5. 提交新事务</span>        <span class="token comment" spellcheck="true">// 6. resume() 恢复外层事务</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> Propagation<span class="token punctuation">.</span>NESTED<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. TransactionInterceptor.invoke()</span>        <span class="token comment" spellcheck="true">// 2. createTransactionIfNecessary()</span>        <span class="token comment" spellcheck="true">// 3. tm.getTransaction() -> handleExistingTransaction()</span>        <span class="token comment" spellcheck="true">//    -> 检测到当前有事务</span>        <span class="token comment" spellcheck="true">//    -> createAndHoldSavepoint() 创建保存点</span>        <span class="token comment" spellcheck="true">// 4. 执行业务代码</span>        <span class="token comment" spellcheck="true">// 5. 如果成功：releaseHeldSavepoint() 释放保存点</span>        <span class="token comment" spellcheck="true">//    如果失败：rollbackToSavepoint() 回滚到保存点</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-关键实现点总结"><a href="#5-6-关键实现点总结" class="headerlink" title="5.6 关键实现点总结"></a>5.6 关键实现点总结</h3><ol><li><p><strong>REQUIRED（默认）</strong></p><ul><li>有事务：加入当前事务</li><li>无事务：创建新事务</li></ul></li><li><p><strong>REQUIRES_NEW</strong></p><ul><li>有事务：挂起当前事务 → 创建新事务 → 提交新事务 → 恢复外层事务</li><li>无事务：创建新事务</li></ul></li><li><p><strong>NESTED</strong></p><ul><li>有事务：创建保存点（Savepoint）→ 失败回滚到保存点，成功释放保存点</li><li>无事务：创建新事务</li></ul></li></ol><h3 id="5-7-核心方法"><a href="#5-7-核心方法" class="headerlink" title="5.7 核心方法"></a>5.7 核心方法</h3><ul><li><code>handleExistingTransaction()</code>：处理已存在事务的情况</li><li><code>suspend()</code>：挂起事务</li><li><code>resume()</code>：恢复事务</li><li><code>createAndHoldSavepoint()</code>：创建保存点</li><li><code>processCommit()</code>：处理提交（区分新事务、加入事务、嵌套事务）</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h3><ol><li><strong>Spring @Transactional 基于 AOP 实现</strong>，通过代理对象拦截方法调用</li><li><strong>代理对象在 Spring 启动时生成</strong>，不是在实际调用时生成</li><li><strong>Spring AOP 使用 AspectJ 的注解和表达式</strong>，但底层是动态代理（JDK 或 CGLIB）</li><li><strong>CGLIB 是代理实现方式</strong>，AspectJ 提供语法和解析器</li><li><strong>事务传播行为通过 PlatformTransactionManager 实现</strong>，不同传播行为有不同的处理逻辑</li><li><strong>每个事务可以设置不同的隔离级别</strong>，通过 Connection.setTransactionIsolation() 实现</li></ol><h3 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h3><ul><li>理解 Spring AOP 和 AspectJ 的区别</li><li>掌握三种常用传播行为的使用场景</li><li>了解代理对象的生成时机</li><li>理解事务传播机制的底层实现原理</li></ul><hr><p><em>本文档整理自 Spring 事务机制相关技术讨论</em></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-事务机制详解&quot;&gt;&lt;a href=&quot;#Spring-事务机制详解&quot; class=&quot;headerlink&quot; title=&quot;Spring 事务机制详解&quot;&gt;&lt;/a&gt;Spring 事务机制详解&lt;/h1&gt;&lt;h2 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; cla
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java NIO Buffer 使用与实现原理</title>
    <link href="https://zhsongdanc.github.io/posts/103.html"/>
    <id>https://zhsongdanc.github.io/posts/103.html</id>
    <published>2023-10-08T02:30:07.000Z</published>
    <updated>2025-11-21T09:51:27.909Z</updated>
    
    <content type="html"><![CDATA[<p>📚 微服务容错与流量治理核心机制笔记<br>时间：2025年11月20日</p><p>一、注册中心的心跳机制：为什么需要双向通信？</p><ol><li>客户端 → 注册中心（心跳续约）<br>目的：证明服务实例存活，防止被误剔除。<br>实现：客户端定期（如 Eureka 默认 30s）发送心跳。<br>优点：轻量、简单、注册中心压力小。</li><li>注册中心 → 客户端（主动探测）<br>目的：<br>应对客户端异常退出（如 kill -9）；<br>防止“假活实例”（进程卡死但心跳正常）；<br>提高服务状态准确性。<br>典型实现：<br>Consul：主动 HTTP/TCP 健康检查；<br>Nacos：对持久化实例进行 TCP 探测；<br>ZooKeeper：通过 Session 机制隐式探测。</li><li>为什么 Eureka 不主动探测？<br>设计哲学：AP 系统，优先保证高可用；<br>风险：可能保留“僵尸实例”；<br>应对：可集成 Spring Boot Actuator，让客户端在健康检查失败时主动停止心跳。</li></ol><p>二、Eureka 的自我保护机制（Self-Preservation）</p><ol><li>设计目标<br>防止网络分区或瞬时故障导致大量健康实例被误删，避免雪崩。</li><li>触发条件（默认）<br>每分钟期望心跳数 = 实例数 × 2（因默认 30s 心跳一次）；<br>若实际心跳数 &lt; 期望值 × 85%（renewal-percent-threshold），则进入自我保护模式。</li><li>自我保护期间行为<br>❌ 停止剔除过期实例；<br>✅ 允许新服务注册；<br>⚠️ 暂停集群间数据同步；<br>✅ 继续提供服务发现（返回所有实例，含可能失效的）；<br>🟥 控制台显示红色警告。</li><li>关键配置<br>yaml<br>eureka:<br>server:<br>enable-self-preservation: true # 默认开启（生产勿关！）<br>renewal-percent-threshold: 0.85<br>instance:<br>lease-renewal-interval-in-seconds: 30 # 心跳间隔<br>lease-expiration-duration-in-seconds: 90 # 失效等待时间<br>💡 最佳实践：生产环境务必开启；配合 Actuator 健康检查提升准确性。</li></ol><p>三、Sentinel 核心机制详解</p><ol><li>功能概览<br>✅ 限流（QPS/线程数/关联/链路）<br>✅ 熔断降级（慢调用比例、异常比例）<br>✅ 系统负载保护<br>✅ 热点参数限流<br>✅ 实时监控 + 动态规则（支持 Nacos/Apollo）</li><li>熔断如何工作？<br>Sentinel 自动统计以下指标（基于滑动窗口）：<br>请求总数<br>异常数 / 异常比例<br>平均 RT（响应时间）<br>慢调用比例（耗时 &gt; 阈值的请求占比）<br>熔断策略：<br>类型 触发条件示例</li></ol><hr><p>慢调用比例 10秒内 ≥5 次调用，60% 耗时 &gt; 500ms<br>异常比例 10秒内 ≥5 次调用，错误率 ≥ 50%<br>🔸 注意：只有抛出异常的调用才计入错误；返回错误码不算。<br>3. Sentinel 是轻量级的吗？<br>   ✅ 是！默认在当前线程执行，无额外线程开销；<br>   通过 AOP 式拦截 + 内存滑动窗口统计；<br>   对比 Hystrix 的线程池模型，性能更高、资源占用更少。<br>4. fallback 需要自己实现<br>   java<br>   @SentinelResource(<br>   value = “myService”,<br>   blockHandler = “handleBlocked” // 限流/熔断时调用<br>   )<br>   public String myService() { … }</p><p>public String handleBlocked(BlockException ex) {<br>return “系统繁忙，请稍后再试”;<br>}<br>📌 Sentinel 只负责“拦”，不负责“兜”。</p><p>四、Hystrix vs Sentinel：熔断与限流对比</p><p>能力 Hystrix Sentinel</p><hr><p>熔断（错误率） ✅ 支持 ✅ 支持（+ 慢调用比例）<br>QPS 限流 ❌ 不支持 ✅ 支持<br>并发控制 ✅（线程池 / 信号量） ✅（线程数流控）<br>热点参数限流 ❌ ✅<br>动态规则 困难 ✅（Nacos 等）<br>轻量级（无额外线程） ❌（默认线程池） ✅（默认当前线程）<br>💡 Hystrix = 熔断器 + 隔离器，不是限流器。</p><p>五、JDBC 查询为何无法被线程中断？</p><ol><li>根本原因<br>JDBC 使用阻塞 I/O（socket read/write）；<br>Java 的 Thread.interrupt() 对阻塞 I/O 无效；<br>线程会一直等待数据库返回，直到：<br>查询完成，或<br>socket/database 超时。</li><li>正确中断 JDBC 的方法<br>✅ 方案1：Statement.cancel()<br>驱动向数据库发送取消请求（如 MySQL 的 KILL QUERY）；<br>需持有原 Statement 对象。<br>✅ 方案2：setQueryTimeout(seconds)<br>java<br>PreparedStatement ps = conn.prepareStatement(sql);<br>ps.setQueryTimeout(3); // 最多执行3秒<br>驱动内部启动监控线程，超时后自动调用 cancel()；<br>强烈推荐在所有可能慢的 SQL 上设置！</li></ol><p>六、Hystrix 超时与熔断的真实机制</p><ol><li>熔断 ≠ 线程中断<br>熔断：基于错误率的状态机（CLOSED → OPEN）；<br>进入 OPEN 状态后，直接拒绝请求，不执行 run() 方法；<br>与线程中断无关。</li><li>超时才涉及线程中断（仅线程池模式）<br>主线程调用 future.get(timeout)；<br>超时后：<br>主线程立即走 fallback；<br>同时调用 future.cancel(true) 尝试 interrupt 工作线程；<br>但若 run() 中是 JDBC 查询，interrupt 无效 → 工作线程仍卡住。</li><li>为什么主线程还能返回？<br>主线程和工作线程解耦；<br>主线程只关心“是否在 timeout 内拿到结果”，不等待工作线程真正结束；<br>用户早已收到 fallback 响应，但工作线程仍在后台执行（直到 DB 返回）。</li><li>风险<br>Hystrix 线程池可能被慢查询占满；<br>数据库连接未释放，可能导致连接池耗尽；<br>数据库仍在执行“已取消”的查询，浪费资源。<br>✅ 解决方案：必须配合 setQueryTimeout()，从源头控制查询耗时。</li></ol><p>七、总结与建议</p><p>场景 推荐方案</p><hr><p>服务注册发现 Eureka（AP，高可用） / Nacos（灵活） / Consul（CP，强一致）<br>熔断 + 限流一体化 ✅ Sentinel（轻量、功能全、动态规则）<br>仅需熔断（老系统） Hystrix（注意线程开销）或 Resilience4j<br>数据库防慢查询 所有 SQL 设置 setQueryTimeout() + 监控慢日志<br>生产环境稳定性 注册中心开启自我保护 + 客户端健康检查 + 服务端熔断限流<br>🌟 核心思想：<br>注册中心：宁可多留，不可错删（AP）；<br>流量治理：既要防“太多请求”，也要防“下游太慢”；<br>数据库访问：永远不要信任 SQL 执行时间，必须设超时！</p><p>📝 本笔记可作为微服务容错设计的参考手册。建议结合实际项目配置实践，并持续监控指标（QPS、RT、错误率、线程池状态）。</p><p>✅ 完</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;📚 微服务容错与流量治理核心机制笔记&lt;br&gt;时间：2025年11月20日&lt;/p&gt;
&lt;p&gt;一、注册中心的心跳机制：为什么需要双向通信？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端 → 注册中心（心跳续约）&lt;br&gt;目的：证明服务实例存活，防止被误剔除。&lt;br&gt;实现：客户端定期（如 Eu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Java NIO Buffer 使用与实现原理</title>
    <link href="https://zhsongdanc.github.io/posts/106.html"/>
    <id>https://zhsongdanc.github.io/posts/106.html</id>
    <published>2023-10-08T02:30:07.000Z</published>
    <updated>2025-11-27T05:59:18.391Z</updated>
    
    <content type="html"><![CDATA[<ol><li>题目：Kafka 的日志分段（Log Segmentation）机制是什么？如何影响读写性能和数据清理？<br>核心考点：日志存储底层设计、性能优化逻辑<br>详细答案：<br>Kafka 的日志分段是将 Topic 分区的日志文件（.log）按 “大小 + 时间” 拆分为多个小文件段（Segment），每个 Segment 包含 3 类文件：<br>.log：存储消息实体（默认单个文件最大 1GB，可通过 log.segment.bytes 配置）；<br>.index：消息偏移量（offset）到物理存储位置的索引；<br>.timeindex：消息时间戳到 offset 的索引。<br>（1）核心作用（影响读写性能）<br>写入性能：Kafka 采用 “顺序写磁盘”，分段后无需在单个大文件末尾追加，避免磁盘碎片和大文件 IO 阻塞，同时支持并行刷盘（每个 Segment 独立刷盘）；<br>读取性能：通过 .index 和 .timeindex 实现 “二分查找”，无需遍历整个日志文件。例如根据 offset 查找消息时，先定位到对应 Segment（通过文件名前缀的起始 offset 判断），再在该 Segment 的 .index 中二分查找物理位置，直接读取 .log 文件对应数据，时间复杂度 O (logN)；<br>避免文件过大：单个 Segment 最大 1GB，即使分区数据量达 TB 级，也不会出现 “大文件无法打开”“IO 效率下降” 问题。<br>（2）对数据清理的影响<br>Kafka 的数据清理（日志保留）基于 Segment 粒度，而非单条消息：<br>日志保留策略：支持 “按时间（log.retention.hours）”“按大小（log.retention.bytes）” 两种策略，超过阈值的 Segment 会被后台线程（LogCleaner）异步清理；<br>清理效率优化：仅清理过期的 Segment，不会影响正在写入的活跃 Segment（当前最大 offset 所在的 Segment），避免清理操作阻塞读写；<br>压缩策略支持：对于启用压缩的 Topic（compression.type 非 none），LogCleaner 会对过期 Segment 进行 “日志压缩”（保留相同 key 的最新消息），而非直接删除，节省存储空间。<br>（3）RocketMQ 的存储机制（CommitLog + ConsumeQueue）<br>RocketMQ 采用 “混合型存储架构”，与 Kafka 的分段存储不同：<br>存储架构：<br>CommitLog：所有 Topic 的消息统一存储在单个 CommitLog 文件中（按时间顺序追加），默认单个文件 1GB，通过 mapedFileSizeCommitLog 配置；<br>ConsumeQueue：每个 Topic 的每个 Queue 对应一个 ConsumeQueue 文件，存储消息在 CommitLog 中的物理位置（offset、size、tagHashcode），类似 Kafka 的 .index 文件；<br>IndexFile：按消息 key 和时间戳建立索引，支持按 key 和时间范围查询消息。<br>核心特点：<br>写入性能：所有消息顺序写入 CommitLog，充分利用顺序写磁盘的优势（类似 Kafka）；<br>读取性能：消费者通过 ConsumeQueue 快速定位消息在 CommitLog 中的位置，然后批量读取 CommitLog（ConsumeQueue 文件较小，可全部加载到内存）；<br>文件滚动：CommitLog 和 ConsumeQueue 都按大小和时间滚动（默认 1GB 或 72 小时），过期文件自动删除。<br>（4）Kafka vs RocketMQ 存储机制对比<table><thead><tr><th>对比维度</th><th>Kafka</th><th>RocketMQ</th></tr></thead><tbody><tr><td>存储模型</td><td>分区独立存储（每个分区独立的 .log 文件）</td><td>统一存储（所有 Topic 共享 CommitLog）</td></tr><tr><td>索引结构</td><td>每个 Segment 有 .index 和 .timeindex</td><td>每个 Queue 有 ConsumeQueue，全局有 IndexFile</td></tr><tr><td>文件组织</td><td>按分区 + Segment 组织</td><td>按 Topic + Queue 组织，但数据统一在 CommitLog</td></tr><tr><td>优势</td><td>分区隔离，故障影响范围小</td><td>统一存储，写入性能更高，存储利用率高</td></tr><tr><td>劣势</td><td>小分区多时文件数多，管理复杂</td><td>所有消息混在一起，单文件故障影响大</td></tr><tr><td>适用场景</td><td>多租户、分区独立管理</td><td>高吞吐量、统一管理</td></tr></tbody></table></li></ol><p>为什么会有这种差别？<br>设计理念不同：<br>Kafka 的设计理念是 “分区即存储单元”，每个分区独立存储，便于分区级别的管理和扩展，适合多租户场景；<br>RocketMQ 的设计理念是 “统一存储 + 逻辑队列”，所有消息物理上集中存储，逻辑上通过 ConsumeQueue 分离，减少文件数量，提升写入性能。<br>性能权衡：<br>Kafka 的分区独立存储：写入时每个分区独立顺序写，但分区数多时文件数多，可能影响文件系统性能；<br>RocketMQ 的统一存储：所有消息写入同一个 CommitLog，顺序写性能最优，但需要额外的 ConsumeQueue 来支持按 Queue 消费。<br>面试加分点：<br>提到 Segment 文件名规则：例如 00000000000000000000.log（起始 offset 为 0）、00000000000000012345.log（起始 offset 为 12345）；<br>结合源码：Kafka 的 Log 类（org.apache.kafka.logs.Log）管理 Segment 集合，roll() 方法负责创建新 Segment，deleteOldSegments() 方法负责清理过期 Segment；RocketMQ 的 DefaultMessageStore 类管理 CommitLog 和 ConsumeQueue，ReputMessageService 负责将 CommitLog 的消息分发到 ConsumeQueue。<br>2. 题目：Kafka 消费者的 Rebalance 机制原理是什么？触发条件有哪些？如何避免 Rebalance 导致的消费停顿？<br>核心考点：消费者组协调机制、故障处理、性能优化<br>详细答案：<br>（1）Rebalance 定义<br>Rebalance 是消费者组（Consumer Group）的 “分区重新分配” 机制：当消费者组内成员变化（新增 / 下线）、Topic 分区数变化、订阅 Topic 变化时，Coordinator（协调者，由 Broker 担任）会重新将 Topic 分区分配给组内消费者，保证 “一个分区仅被一个消费者消费”（分区数 ≤ 消费者数时，部分消费者无分区；分区数 &gt; 消费者数时，部分消费者分配多个分区）。<br>（2）Rebalance 核心流程（基于 Kafka 2.0+ 版本，Coordinator 机制）<br>选举 Coordinator：消费者组初始化时，所有消费者向 Kafka 集群发送请求，通过 “消费者组 ID 的哈希值 % 50（<strong>consumer_offsets 主题的分区数，默认 50）” 确定 Coordinator 所在的 Broker（</strong>consumer_offsets 分区的 Leader）；<br>加入组阶段（Join Group）：<br>消费者向 Coordinator 发送 JoinGroupRequest，携带自身订阅的 Topic、分区分配策略（如 Range/RoundRobin/Sticky）；<br>Coordinator 选举 “组 leader”（通常是第一个加入组的消费者），并将所有消费者信息和订阅信息发送给组 leader；<br>分配分区阶段（Assign Partitions）：<br>组 leader 根据预设的分配策略，计算分区分配方案（如 RoundRobin 均匀分配分区）；<br>组 leader 将分配方案通过 SyncGroupRequest 发送给 Coordinator，再由 Coordinator 同步给所有消费者；<br>确认阶段：消费者接收分配方案后，开始消费对应分区的消息，并向 Coordinator 发送心跳（默认 3 秒），维持组成员身份。<br>（3）触发 Rebalance 的条件（3 类核心场景）<br>消费者组成员变化：<br>主动触发：消费者正常退出（调用 close() 方法）；<br>被动触发：消费者心跳超时（session.timeout.ms，默认 45 秒）、消费超时（max.poll.interval.ms，默认 5 分钟）；<br>Topic 元数据变化：Topic 新增分区（通过 kafka-topics.sh –alter 扩容）、消费者订阅新的 Topic；<br>其他场景：消费者组重启（所有消费者下线后重新加入）、Coordinator 节点故障（重新选举 Coordinator 后触发 Rebalance）。<br>（4）如何避免 Rebalance 导致的消费停顿？<br>Rebalance 期间，消费者组会暂停所有消费（“消费黑洞”），直到分区分配完成，因此需从 “减少 Rebalance 触发”“缩短 Rebalance 耗时”“优化分配策略” 三方面优化：<br>避免不必要的 Rebalance：<br>合理配置超时参数：session.timeout.ms 设为 30-60 秒（避免网络抖动误判下线），max.poll.interval.ms 设为消费批次的 2-3 倍（避免消费慢导致超时）；<br>消费者正常退出：调用 consumer.close() 而非强制 kill 进程，让 Coordinator 主动移除成员，避免触发 Rebalance；<br>固定消费者组订阅的 Topic：避免动态订阅导致元数据变化；<br>缩短 Rebalance 耗时：<br>减少消费者组规模：将大消费者组拆分为多个小组（如按业务线拆分），减少 JoinGroup 阶段的数据传输和分配计算耗时；<br>优化分区分配策略：优先使用 Sticky 策略（粘性分配），Rebalance 时尽量保留原有分区分配，仅调整变化部分，减少分区迁移开销（默认 Range 策略易导致分配不均，RoundRobin 策略迁移开销大）；<br>降级 Rebalance 影响：<br>启用消费者组静态成员（Kafka 2.3+ 特性）：通过 group.instance.id 配置消费者实例 ID，消费者重启后仍能复用原有分区分配，避免触发全量 Rebalance；<br>监控 Rebalance 状态：通过 Kafka 监控指标（如 kafka.consumer:type=consumer-coordinator-metrics,client-id=<em>,group-id=</em>:RebalanceRate）实时告警，及时排查异常触发原因。<br>（5）RocketMQ 的负载均衡机制<br>RocketMQ 采用 “客户端主动拉取 + 服务端分配” 的负载均衡机制，与 Kafka 的 Coordinator 协调不同：<br>核心机制：<br>消费者启动时：消费者向 NameServer 获取 Topic 的路由信息（包含所有 Broker 和 Queue 信息）；<br>Queue 分配策略：消费者客户端根据预设策略（如平均分配、一致性哈希）计算自己负责的 Queue 列表，无需服务端协调；<br>动态调整：消费者定期（默认 20 秒）重新拉取路由信息，当 Queue 数量变化时，自动重新分配 Queue。<br>负载均衡策略：<br>平均分配（AllocateMessageQueueAveragely）：Queue 平均分配给消费者，类似 Kafka 的 RoundRobin；<br>一致性哈希（AllocateMessageQueueConsistentHash）：按消费者 ID 一致性哈希分配，保证同一消费者组内分配稳定；<br>机房优先（AllocateMessageQueueByMachineRoom）：优先分配同机房的 Queue，降低跨机房网络开销。<br>与 Kafka Rebalance 的区别：<br>| 对比维度 | Kafka Rebalance | RocketMQ 负载均衡 |<br>|———|—————-|——————|<br>| 协调方式 | 服务端协调（Coordinator） | 客户端自主分配 |<br>| 触发时机 | 成员变化、分区变化时统一触发 | 消费者启动、路由变化时各自触发 |<br>| 分配粒度 | 分区级别 | Queue 级别 |<br>| 消费停顿 | 全组暂停，等待分配完成 | 无全局停顿，仅重新分配的 Queue 短暂停顿 |<br>| 复杂度 | 需要选举组 leader、同步分配方案 | 客户端独立计算，无需服务端协调 |</p><p>为什么会有这种差别？<br>架构设计不同：<br>Kafka 采用 “服务端协调” 模式，通过 Coordinator 统一管理消费者组，保证分配的一致性和全局最优，但需要全组暂停等待分配；<br>RocketMQ 采用 “客户端自主” 模式，每个消费者独立计算分配方案，无需服务端协调，避免全局停顿，但可能出现短暂的不一致（最终一致）。<br>适用场景：<br>Kafka 的 Rebalance：适合需要严格保证分配一致性的场景，但会带来消费停顿；<br>RocketMQ 的负载均衡：适合对停顿敏感的场景，通过客户端自主分配避免全局停顿，但需要客户端实现分配逻辑。<br>面试加分点：<br>区分 “主动 Rebalance” 和 “被动 Rebalance”，并举例说明场景；<br>提到 Sticky 策略的优势：解决 Range 策略的 “分区倾斜” 问题（如 10 个分区分给 3 个消费者，前 2 个分 4 个，最后 1 个分 2 个）；<br>结合源码：Kafka 的 Coordinator 核心逻辑在 GroupCoordinator 类，Rebalance 状态机（Unstable/Empty/PreparingRebalance/CompletingRebalance/Stable）；RocketMQ 的负载均衡逻辑在 RebalanceImpl 类，AllocateMessageQueueStrategy 接口定义分配策略。<br>3. 题目：Kafka 的 ISR（In-Sync Replicas）集合如何维护？Leader 选举时为什么优先从 ISR 中选择？ISR 收缩 / 扩容的阈值是什么？<br>核心考点：副本同步机制、高可用设计、数据一致性保障<br>详细答案：<br>（1）ISR 定义<br>ISR 是 “同步副本集合”，指与 Leader 副本保持数据同步的 Follower 副本集合（Leader 自身始终在 ISR 中）。Kafka 通过 ISR 保证分区数据的高可用和一致性，避免因 Follower 落后过多导致数据丢失。<br>（2）ISR 的维护机制（基于 HW/LEO 指标）<br>Kafka 用两个核心指标跟踪副本同步状态：<br>LEO（Log End Offset）：每个副本的日志末尾偏移量，即当前副本最新消息的 offset + 1（如副本包含 offset 0-5 的消息，LEO=6）；<br>HW（High Watermark）：高水位线，指所有副本都已同步的消息 offset 上限（仅 HW 以下的消息对消费者可见）。<br>ISR 的维护流程：<br>Follower 同步 Leader 数据：Follower 启动后会向 Leader 发送 FetchRequest 请求，批量拉取 Leader 的消息并写入本地日志，更新自身 LEO；<br>Leader 更新 Follower 同步状态：Leader 接收 Follower 的 FetchRequest 后，会记录每个 Follower 的 LEO，并计算当前分区的 HW（所有副本 LEO 的最小值）；<br>ISR 动态调整：<br>若 Follower 的 LEO 与 Leader 的 LEO 差距 ≤ replica.lag.time.max.ms（默认 10 秒），则认为该 Follower 同步正常，保留在 ISR 中；<br>若 Follower 超过 10 秒未向 Leader 发送 FetchRequest，或 LEO 差距持续大于阈值，则 Leader 会将其从 ISR 中移除（ISR 收缩）；<br>若被移除的 Follower 后续重新追上 Leader 的 LEO（差距 ≤ 阈值），则 Leader 会将其重新加入 ISR（ISR 扩容）。<br>（3）Leader 选举优先选择 ISR 副本的原因<br>数据一致性保障：ISR 中的 Follower 与 Leader 数据差距极小（≤10 秒），选举后能最大程度避免数据丢失（若选择非 ISR 副本，其数据可能落后 Leader 大量消息，选举后会导致这些消息丢失）；<br>选举效率高：ISR 副本数量通常较少（默认副本数 3，ISR 至少包含 Leader + 1 个 Follower），无需遍历所有副本，缩短选举耗时；<br>避免脑裂：非 ISR 副本可能因网络分区等原因与集群断开连接，若选为 Leader，可能出现 “双 Leader”（原 Leader 恢复后与新 Leader 同时写入数据），破坏数据一致性。<br>（4）ISR 收缩 / 扩容的阈值<br>收缩阈值：<br>时间阈值：replica.lag.time.max.ms（默认 10 秒）—— Follower 超过该时间未向 Leader 发送 Fetch 请求；<br>（旧版本兼容）消息数阈值：replica.lag.max.messages（默认 -1，已废弃）—— 早期版本用 “Follower 与 Leader 的 LEO 差距消息数” 作为阈值，现因消息大小不统一，改为时间阈值；<br>扩容阈值：被移除的 Follower 重新追上 Leader 的 LEO（差距 ≤ replica.lag.time.max.ms），且能稳定发送 Fetch 请求，Leader 会将其重新加入 ISR。<br>（5）RocketMQ 的副本同步机制（同步复制 vs 异步复制）<br>RocketMQ 采用 “主从复制” 机制，与 Kafka 的 ISR 机制不同：<br>复制模式：<br>同步复制（SYNC_MASTER）：生产者发送消息后，Master 需等待所有 Slave 同步完成才返回成功，保证数据不丢失（类似 Kafka 的 acks=-1）；<br>异步复制（ASYNC_MASTER）：生产者发送消息后，Master 立即返回成功，Slave 异步同步，性能更高但可能丢失数据（类似 Kafka 的 acks=1）。<br>HA 机制（高可用）：<br>主从切换：当 Master 故障时，Slave 自动切换为 Master（需配置 brokerRole=SYNC_MASTER 或 ASYNC_MASTER）；<br>数据同步：Slave 通过定时拉取（Pull）或 Master 主动推送（Push）同步数据，同步延迟通过 haHousekeepingService 监控。<br>与 Kafka ISR 的区别：<br>| 对比维度 | Kafka ISR | RocketMQ 主从复制 |<br>|———|———–|——————|<br>| 同步判断 | 基于时间阈值（replica.lag.time.max.ms） | 基于同步确认（同步复制需等待确认） |<br>| 副本集合 | 动态维护 ISR 集合 | 固定的 Master-Slave 关系 |<br>| Leader 选举 | 从 ISR 中选举，优先选择同步的副本 | Slave 自动切换为 Master |<br>| 数据一致性 | HW 机制保证可见性 | 同步复制保证强一致性 |<br>| 性能影响 | ISR 收缩时可能影响写入 | 同步复制延迟高，异步复制性能好 |</p><p>为什么会有这种差别？<br>设计理念不同：<br>Kafka 的 ISR：动态维护同步副本集合，允许部分副本暂时不同步，通过 HW 机制保证数据一致性，适合大规模集群；<br>RocketMQ 的主从复制：采用传统的主从架构，Master-Slave 关系固定，同步复制保证强一致性，但性能较低。<br>适用场景：<br>Kafka ISR：适合多副本（3+）场景，通过 ISR 动态调整平衡性能和一致性；<br>RocketMQ 主从复制：适合双副本场景，同步复制保证强一致性，异步复制追求高性能。<br>面试加分点：<br>提到 min.insync.replicas（默认 1）：生产者配置 acks=-1（即 all）时，消息需被 ISR 中至少 min.insync.replicas 个副本确认后才算发送成功，进一步保障数据不丢失；<br>结合故障场景：若 ISR 中所有 Follower 都故障，Leader 会等待 replica.lag.time.max.ms 后，允许从非 ISR 副本选举 Leader（需开启 unclean.leader.election.enable，默认 false），但会导致数据丢失，生产环境不建议开启；<br>RocketMQ 的同步复制配置：通过 brokerRole=SYNC_MASTER 和 flushDiskType=SYNC_FLUSH 实现强一致性，但会牺牲性能。<br>4. 题目：Kafka 的消息投递语义（At-Least-Once/At-Most-Once/Exactly-Once）如何实现？生产端和消费端分别需要做哪些配置？<br>核心考点：投递语义原理、配置实践、数据一致性保障<br>详细答案：<br>Kafka 的投递语义是指 “消息从生产者发送到消费者接收的过程中，消息被处理的次数”，核心依赖生产端的 “确认机制” 和消费端的 “offset 提交机制” 实现。<br>（1）At-Most-Once（最多一次）<br>定义：消息可能被处理 0 次或 1 次，不会重复处理，但可能丢失；<br>实现原理：消费端 “先提交 offset，后处理消息”—— 消费者拉取消息后，立即提交 offset，若处理消息时故障（如进程崩溃），重启后会从已提交的 offset 之后消费，导致未处理的消息丢失；<br>生产端配置：无特殊要求（默认即可）；<br>消费端配置：<br>启用自动提交 offset（enable.auto.commit=true）；<br>缩短自动提交间隔（auto.commit.interval.ms=1000），减少未处理消息丢失的概率。<br>适用场景：对数据一致性要求低，允许丢失的场景（如日志收集、非核心监控数据）。<br>（2）At-Least-Once（至少一次）<br>定义：消息至少被处理 1 次，不会丢失，但可能重复处理；<br>实现原理：<br>生产端：启用消息确认（acks=-1 或 all），消息需被 ISR 中至少 min.insync.replicas 个副本确认后才算发送成功，避免生产者重试导致消息丢失；<br>消费端：“先处理消息，后提交 offset”—— 消费者处理完消息后，手动提交 offset，若处理成功后未提交 offset 故障，重启后会重新拉取该批消息，导致重复处理；<br>生产端配置：<br>acks=-1（或 all）：消息需被 ISR 中所有副本确认；<br>retries=Integer.MAX_VALUE（默认 2147483647）：开启无限重试，避免网络抖动导致消息发送失败；<br>max.in.flight.requests.per.connection=1（可选）：保证重试消息的顺序性（避免后发送的消息先到达，导致重试消息乱序）；<br>消费端配置：<br>禁用自动提交 offset（enable.auto.commit=false）；<br>处理完消息后，手动调用 consumer.commitSync()（同步提交，阻塞直到成功）或 consumer.commitAsync()（异步提交，非阻塞）；<br>适用场景：对数据丢失敏感，允许重复处理的场景（如支付、订单创建，可通过业务幂等性解决重复问题）。<br>（3）Exactly-Once（恰好一次）<br>定义：消息被处理且仅被处理 1 次，无丢失、无重复，是最严格的投递语义；<br>实现原理：Kafka 0.11 版本后通过 “幂等性生产 + 事务机制” 实现，核心是 “消息去重 + offset 与业务操作原子提交”；<br>生产端配置（幂等性 + 事务）：<br>启用幂等性（enable.idempotence=true）：生产者会为每个消息分配唯一的 ProducerId + SequenceNumber，Broker 接收消息时会去重（相同 ProducerId + SequenceNumber 的消息仅存储一次）；<br>配置事务 ID（transactional.id=xxx）：保证生产者重启后仍能恢复事务状态，避免重复提交；<br>配合 acks=-1 和 retries=Integer.MAX_VALUE，确保消息不丢失；<br>消费端配置（事务感知）：<br>禁用自动提交 offset（enable.auto.commit=false）；<br>订阅 Topic 时指定事务隔离级别（isolation.level=read_committed）：仅消费已提交的事务消息，避免消费到事务回滚的消息；<br>事务内原子提交：将 “处理消息” 和 “提交 offset” 纳入同一个事务（通过 KafkaTransactionManager 整合 Spring 事务），确保两者要么同时成功，要么同时回滚；<br>补充方案：若不使用 Kafka 事务，可通过 “业务幂等性 + At-Least-Once” 间接实现 Exactly-Once（如消息携带唯一 ID，消费端处理前先查询是否已处理）。<br>适用场景：对数据一致性要求极高的场景（如金融交易、核心业务数据同步）。<br>（4）RocketMQ 的消息投递语义实现<br>RocketMQ 的消息投递语义实现方式与 Kafka 类似，但细节有差异：<br>At-Most-Once（最多一次）：<br>实现方式：消费端 “先提交 offset，后处理消息”（RocketMQ 中 offset 存储在本地或远程，通过 CONSUME_FROM_LAST_OFFSET 配置）；<br>配置：消费模式设置为 CONSUME_MODE=CONCURRENTLY（并发消费），消费成功后立即提交 offset。<br>At-Least-Once（至少一次）：<br>实现方式：<br>生产端：同步发送（send() 方法同步等待），或异步发送后检查 SendResult，确保消息发送成功；<br>消费端：”先处理消息，后提交 offset”，消费模式设置为 CONSUME_MODE=ORDERLY（顺序消费）或手动提交 offset；<br>配置：生产端使用同步发送，消费端处理完消息后调用 consumer.updateConsumeOffset() 提交 offset。<br>Exactly-Once（恰好一次）：<br>实现方式：<br>事务消息：RocketMQ 4.3+ 支持事务消息，通过 TransactionListener 实现本地事务和消息发送的原子性；<br>幂等性：生产端通过 MessageId（全局唯一）或业务唯一键实现去重，消费端通过业务幂等性保证不重复处理；<br>配置：<br>生产端：使用 TransactionMQProducer，实现 TransactionListener 接口，在 executeLocalTransaction() 中执行本地事务；<br>消费端：消费前检查消息是否已处理（通过数据库或缓存记录 MessageId），实现业务幂等性。</p><p>Kafka vs RocketMQ 投递语义对比：<br>| 对比维度 | Kafka | RocketMQ |<br>|———|——-|———-|<br>| At-Most-Once | 自动提交 offset | 消费模式 + offset 提交策略 |<br>| At-Least-Once | 手动提交 offset + acks=-1 | 同步发送 + 手动提交 offset |<br>| Exactly-Once | 事务 + 幂等性生产 | 事务消息 + 业务幂等性 |<br>| 事务支持 | Kafka 0.11+ 支持事务 | RocketMQ 4.3+ 支持事务消息 |<br>| 幂等性 | Broker 端去重（ProducerId + SequenceNumber） | 客户端实现（MessageId 或业务键） |</p><p>为什么会有这种差别？<br>事务实现方式不同：<br>Kafka 的事务：基于 ProducerId + SequenceNumber 的 Broker 端去重，配合事务机制实现跨分区事务；<br>RocketMQ 的事务消息：基于两阶段提交（2PC），通过 TransactionListener 实现本地事务和消息发送的协调，更适合业务场景。<br>幂等性实现位置不同：<br>Kafka：Broker 端维护去重缓存，自动去重，对客户端透明；<br>RocketMQ：客户端通过 MessageId 或业务唯一键实现去重，更灵活但需要客户端实现。<br>面试加分点：<br>解释幂等性生产的底层逻辑：Kafka 的 Broker 端通过 ProducerId（生产者启动时分配）和 SequenceNumber（每个分区递增）维护去重缓存，缓存默认保留 7 天；RocketMQ 通过 MessageId（包含 Broker IP、进程 ID、消息偏移量）保证全局唯一，客户端通过 MessageId 实现去重；<br>区分 read_committed 和 read_uncommitted（默认）：read_uncommitted 会消费未提交的事务消息，可能出现 “脏读”；<br>结合实践：Kafka 通过 @Transactional 注解和 KafkaTransactionManager 实现事务提交；RocketMQ 通过 TransactionMQProducer 和 TransactionListener 实现事务消息。<br>5. 题目：Kafka 的索引文件（.index）和日志文件（.log）如何配合实现消息的快速查找？索引的数据结构是什么？为什么不用 B+ 树？<br>核心考点：索引设计、IO 优化、数据结构选型<br>详细答案：<br>（1）索引文件与日志文件的配合逻辑<br>Kafka 的索引是 “稀疏索引”（非稠密索引），即不针对每条消息建立索引，而是每隔一定间隔（默认 4KB，通过 index.interval.bytes 配置）为一条消息建立索引项，索引项包含两个核心信息：<br>相对 offset：当前消息在 Segment 内的偏移量（如 Segment 起始 offset 为 1000，消息实际 offset 为 1005，则相对 offset 为 5）；<br>物理位置（position）：消息在 .log 文件中的字节偏移量（如 1024 字节处）。<br>查找流程（以根据 offset 查找消息为例）：<br>定位 Segment：根据目标 offset 遍历分区的 Segment 列表，找到 “起始 offset ≤ 目标 offset &lt; 下一个 Segment 起始 offset” 的目标 Segment（如目标 offset 为 1005，找到起始 offset 为 1000 的 Segment）；<br>计算相对 offset：目标相对 offset = 目标 offset - Segment 起始 offset（1005 - 1000 = 5）；<br>二分查找索引：在目标 Segment 的 .index 文件中，通过二分查找找到 “小于等于目标相对 offset” 的最大索引项（如索引项中相对 offset 为 4，对应物理位置 896 字节）；<br>遍历日志文件：从索引项对应的物理位置（896 字节）开始，顺序遍历 .log 文件，直到找到目标 offset 对应的消息（因是稀疏索引，需少量顺序扫描，代价极低）。<br>（2）索引的数据结构：稀疏索引（基于数组的有序存储）<br>.index 文件是二进制文件，索引项按相对 offset 有序排列（数组结构），每个索引项固定 8 字节（4 字节相对 offset + 4 字节物理位置），因此支持高效的二分查找（数组随机访问时间复杂度 O (1)，二分查找 O (logN)）。<br>（3）为什么不用 B+ 树？<br>Kafka 选择稀疏索引而非 B+ 树，核心是为了适配 “顺序写 + 批量读” 的场景，平衡索引效率、存储空间和 IO 开销：<br>IO 开销问题：B+ 树是 “稠密索引”（或半稠密索引），需要为大量消息建立索引项，且树结构的插入 / 查询会产生随机 IO（B+ 树的节点分散存储），而 Kafka 的日志是顺序写，稀疏索引的数组结构支持顺序读 / 写，契合磁盘 IO 特性（顺序 IO 效率是随机 IO 的 100 倍以上）；<br>存储空间问题：B+ 树的索引项较多（如 1 亿条消息需 1 亿个索引项），存储空间大；而稀疏索引每隔 4KB 建立一个索引项（假设每条消息 1KB，约每 4 条消息一个索引项），索引文件大小仅为日志文件的 1/1000 左右，大幅节省存储空间；<br>查询效率足够用：Kafka 的核心场景是 “批量消费消息”（消费者按 offset 顺序拉取），而非 “随机查询单条消息”。稀疏索引的 “二分查找 + 少量顺序扫描” 足以满足需求，且批量消费时可缓存索引项，进一步提升效率；<br>维护成本低：B+ 树需要维护树结构的平衡（如红黑树的旋转操作），插入消息时开销较大；而稀疏索引是数组结构，插入时仅需在文件末尾追加索引项，维护成本极低。<br>（4）RocketMQ 的索引机制（ConsumeQueue + IndexFile）<br>RocketMQ 采用 “双层索引” 机制，与 Kafka 的稀疏索引不同：<br>索引结构：<br>ConsumeQueue：每个 Topic 的每个 Queue 对应一个 ConsumeQueue 文件，存储消息在 CommitLog 中的物理位置（CommitLogOffset、消息大小、TagHashcode），每个条目固定 20 字节；<br>IndexFile：按消息 key 和时间戳建立索引，支持按 key 和时间范围查询，每个 IndexFile 包含 500 万个哈希槽（HashSlot）和 2000 万个索引条目（IndexEntry）。<br>查找流程：<br>按 Queue 查找：消费者通过 ConsumeQueue 快速定位消息在 CommitLog 中的位置，然后批量读取 CommitLog（类似 Kafka 的 .index）；<br>按 key 查找：通过 IndexFile 的哈希表快速定位消息，时间复杂度 O(1)（Kafka 不支持按 key 直接查找）；<br>按时间查找：通过 IndexFile 的时间索引，二分查找时间范围内的消息（类似 Kafka 的 .timeindex）。<br>与 Kafka 索引的对比：<br>| 对比维度 | Kafka 稀疏索引 | RocketMQ 双层索引 |<br>|———|————–|——————|<br>| 索引粒度 | 每 4KB 一个索引项（稀疏） | ConsumeQueue 每条消息一个条目（稠密） |<br>| 索引文件 | .index（offset 索引）+ .timeindex（时间索引） | ConsumeQueue（位置索引）+ IndexFile（key/时间索引） |<br>| 查找方式 | 二分查找 + 顺序扫描 | 直接定位（ConsumeQueue）或哈希查找（IndexFile） |<br>| 存储开销 | 索引文件小（稀疏） | ConsumeQueue 较大（稠密），但文件小可全量加载内存 |<br>| 查询能力 | 支持按 offset 和时间戳查询 | 支持按 offset、key、时间范围查询 |</p><p>为什么不用 B+ 树？为什么 RocketMQ 用稠密索引？<br>Kafka 不用 B+ 树的原因（前面已说明）：<br>顺序写场景，B+ 树会产生随机 IO；稀疏索引足以满足批量消费需求；存储空间和维护成本低。<br>RocketMQ 用稠密索引的原因：<br>ConsumeQueue 文件小（每个 Queue 独立文件，默认 600 万条消息，约 120MB），可全量加载到内存，稠密索引查询更快；<br>支持按 key 查询，需要 IndexFile 的哈希索引，B+ 树不适合哈希查找场景；<br>RocketMQ 的消费模式主要是顺序消费，ConsumeQueue 的顺序读取性能优于稀疏索引的顺序扫描。<br>为什么会有这种差别？<br>设计目标不同：<br>Kafka：追求高吞吐量，索引设计以 “节省存储 + 批量读取” 为目标，稀疏索引足够用；<br>RocketMQ：追求功能全面（支持按 key 查询），索引设计以 “快速定位 + 灵活查询” 为目标，稠密索引 + 哈希索引更适合。<br>文件组织不同：<br>Kafka：每个分区独立的索引文件，分区多时文件数多，稀疏索引减少文件大小；<br>RocketMQ：每个 Queue 独立的 ConsumeQueue，文件小可全量加载内存，稠密索引提升查询性能。<br>面试加分点：<br>提到 .timeindex 的作用：按时间戳查找消息时，先通过 .timeindex 二分查找找到对应时间戳的 offset，再通过 .index 查找物理位置；<br>结合 index.interval.bytes 配置：该值越小，索引越稠密，查询速度越快，但索引文件越大；该值越大，索引越稀疏，存储空间越小，但查询时顺序扫描的开销越大（生产环境默认 4KB 是平衡值）；<br>RocketMQ 的 IndexFile 通过哈希槽（HashSlot）和索引条目（IndexEntry）实现 O(1) 的 key 查找，适合按业务 key 查询消息的场景。<br>二、架构设计与高可用<br>6. 题目：Kafka 的 Controller 节点作用是什么？如何选举产生？Controller 故障会导致什么问题？如何保障 Controller 高可用？<br>核心考点：Controller 架构、高可用设计、故障处理<br>详细答案：<br>（1）Controller 节点的核心作用<br>Controller 是 Kafka 集群中的 “主节点”，由某个 Broker 担任，负责管理集群的元数据和协调故障处理，核心职责包括：<br>分区 Leader 选举：当分区的 Leader 故障时，Controller 负责从 ISR 中选举新的 Leader；<br>集群元数据管理：维护 Topic 信息（分区数、副本数、配置）、Broker 信息（在线状态、端口）、分区副本分布，同步给所有 Broker；<br>Broker 上下线管理：监控 Broker 的心跳（通过 ZooKeeper 或内部协议），当 Broker 上线 / 下线时，更新集群元数据，并触发相关分区的 Leader 重选举；<br>分区副本迁移：集群扩容时，Controller 协调分区数据从旧 Broker 迁移到新 Broker，确保数据均衡分布。<br>（2）Controller 的选举过程（基于 Kafka 2.8+ 版本，KRaft 模式兼容）<br>Kafka 有两种 Controller 选举机制，取决于是否启用 KRaft（Kafka Raft 元数据集群）：<br>传统模式（依赖 ZooKeeper）：<br>集群启动时，所有 Broker 向 ZooKeeper 的 /controller 节点发起创建请求（ZooKeeper 保证同一时间仅一个 Broker 能创建成功）；<br>成功创建 /controller 节点的 Broker 成为 Controller，该节点存储 Controller 的 Broker ID 和选举时间戳；<br>其他 Broker 监听 /controller 节点的变化，获取当前 Controller 信息。<br>KRaft 模式（不依赖 ZooKeeper）：<br>集群启动时，预设一组 “控制器节点”（Controller Quorum），通过 Raft 协议选举 Leader（即 Controller）；<br>Raft 协议保证 “多数派存活” 时 Controller 可用，选举出的 Controller 负责管理集群元数据，元数据存储在本地日志中（而非 ZooKeeper）。<br>（3）Controller 故障的影响<br>Controller 是集群的 “大脑”，故障后会导致：<br>无法进行 Leader 选举：分区 Leader 故障后，无法及时选举新 Leader，该分区将不可用；<br>元数据无法更新：Topic 扩容、Broker 上下线等操作无法执行，集群处于 “只读” 状态；<br>分区迁移暂停：正在进行的分区副本迁移会中断，可能导致数据分布不均；<br>短暂的集群抖动：Controller 重新选举期间（约 10-30 秒），集群元数据同步延迟，部分 Broker 可能因元数据不一致导致消息读写异常。<br>（4）Controller 高可用保障<br>传统模式（ZooKeeper）：<br>所有 Broker 都监听 /controller 节点，当 Controller 故障（ZooKeeper 检测到心跳超时），/controller 节点会被删除；<br>其他 Broker 立即重新发起 /controller 节点创建请求，选举新的 Controller（选举耗时约 10-20 秒）；<br>优化配置：缩短 ZooKeeper 会话超时时间（zookeeper.session.timeout.ms，默认 6000 毫秒），加快故障检测速度。<br>KRaft 模式（推荐生产环境使用）：<br>控制器节点组成 Raft 集群（最少 3 个节点），通过 Raft 协议实现元数据的高可用复制；<br>当 Controller 故障时，Raft 集群会快速选举新的 Controller（选举耗时约 1-2 秒），远快于传统模式；<br>元数据存储在本地日志中，支持持久化和故障恢复，无需依赖 ZooKeeper，减少集群复杂度。<br>（5）RocketMQ 的 NameServer 机制<br>RocketMQ 采用 “NameServer 集群” 管理元数据，与 Kafka 的 Controller 不同：<br>核心作用：<br>路由信息管理：维护 Topic 的路由信息（包含所有 Broker 和 Queue 信息），类似 Kafka 的元数据管理；<br>Broker 注册：Broker 启动时向所有 NameServer 注册，定期（默认 30 秒）发送心跳，NameServer 检测到 Broker 下线时更新路由信息；<br>客户端发现：生产者和消费者通过 NameServer 获取 Topic 的路由信息，然后直接与 Broker 通信。<br>架构特点：<br>无状态设计：NameServer 节点之间无数据同步，每个节点独立存储路由信息，Broker 向所有 NameServer 注册；<br>轻量级：NameServer 不参与消息存储和转发，仅负责元数据管理，性能开销小；<br>高可用：NameServer 集群部署（通常 2-4 个节点），任意节点故障不影响服务（客户端可配置多个 NameServer 地址）。<br>与 Kafka Controller 的对比：<br>| 对比维度 | Kafka Controller | RocketMQ NameServer |<br>|———|—————–|——————-|<br>| 职责范围 | 元数据管理 + Leader 选举 + 副本迁移 | 仅元数据管理（路由信息） |<br>| 状态管理 | 有状态（维护集群状态） | 无状态（仅存储路由信息） |<br>| 选举机制 | 通过 ZooKeeper 或 Raft 选举 | 无选举，所有节点平等 |<br>| 数据同步 | Controller 同步元数据给所有 Broker | Broker 向所有 NameServer 注册 |<br>| 故障影响 | Controller 故障导致集群不可用 | NameServer 故障不影响消息收发（客户端缓存路由） |<br>| 扩展性 | Controller 是单点（KRaft 模式可多节点） | NameServer 可水平扩展 |</p><p>为什么会有这种差别？<br>设计理念不同：<br>Kafka Controller：采用 “集中式管理” 模式，Controller 作为集群大脑，统一管理元数据和协调故障处理，保证全局一致性，但成为单点瓶颈；<br>RocketMQ NameServer：采用 “去中心化” 模式，NameServer 仅负责路由信息，不参与业务逻辑，无状态设计便于扩展，但需要客户端缓存路由信息。<br>职责划分不同：<br>Kafka：Controller 负责 Leader 选举、副本迁移等复杂操作，需要维护集群状态；<br>RocketMQ：NameServer 仅负责路由信息，Leader 选举和副本同步由 Broker 自身处理（Master-Slave 切换），职责更单一。<br>适用场景：<br>Kafka Controller：适合需要复杂协调的场景（如分区迁移、副本重分配），但需要保证 Controller 高可用；<br>RocketMQ NameServer：适合简单路由场景，通过无状态设计实现高可用和水平扩展。<br>面试加分点：<br>提到 KRaft 模式的优势：解决传统模式 “ZooKeeper 瓶颈”（如元数据更新频繁导致 ZooKeeper 压力大），提升集群扩展性和稳定性；<br>结合源码：Kafka 传统模式的 Controller 逻辑在 KafkaController 类，KRaft 模式的 Controller 逻辑在 MetadataController 类；RocketMQ 的 NameServer 逻辑在 NamesrvController 类，路由信息存储在 RouteInfoManager 类；<br>生产环境建议：Kafka 2.8+ 版本后推荐启用 KRaft 模式，控制器节点数配置为奇数（3/5 个），确保 Raft 协议的多数派机制；RocketMQ 的 NameServer 建议部署 2-4 个节点，客户端配置所有 NameServer 地址，实现高可用。<br>7. 题目：Kafka 分区副本的同步机制（HW/LEO）是什么？Leader 与 Follower 之间如何保证数据一致性？HW 落后 LEO 过多会有什么影响？<br>核心考点：副本同步原理、数据一致性保障、故障处理<br>详细答案：<br>（1）HW/LEO 定义（核心指标）<br>LEO（Log End Offset）：每个副本的日志末尾偏移量，代表该副本当前已写入的最新消息的 offset + 1（如副本包含 offset 0-10 的消息，LEO=11）；<br>Leader 副本的 LEO：跟踪自身写入的最新消息 offset；<br>Follower 副本的 LEO：跟踪自身从 Leader 拉取并写入本地的最新消息 offset。<br>HW（High Watermark）：高水位线，代表 “所有副本都已同步的消息 offset 上限”，仅 HW 以下的消息（offset &lt; HW）对消费者可见（即消费者只能消费 offset 0 到 HW-1 的消息）。<br>（2）副本同步机制流程<br>Leader 接收消息：生产者发送消息到 Leader 副本，Leader 写入本地日志后，更新自身 LEO；<br>Follower 拉取消息：Follower 定期（默认每 500 毫秒，可通过 replica.fetch.wait.max.ms 配置）向 Leader 发送 FetchRequest 请求，拉取 Leader 日志中未同步的消息；<br>Follower 写入消息：Follower 接收消息后，写入本地日志，更新自身 LEO，并在 FetchResponse 中告知 Leader 自己的最新 LEO；<br>Leader 更新 HW：Leader 收集所有副本（包括自身）的 LEO，计算当前分区的 HW = 所有副本 LEO 的最小值；<br>同步 HW 给 Follower：Leader 在下次 FetchResponse 中，将最新的 HW 发送给所有 Follower，Follower 接收后更新自身的 HW。<br>（3）Leader 与 Follower 的数据一致性保障<br>通过以下机制确保 Leader 故障后，Follower 选举为新 Leader 时数据不丢失、不重复：<br>ISR 集合过滤：仅 ISR 中的 Follower 参与 Leader 选举，确保新 Leader 与原 Leader 数据差距极小；<br>HW 可见性控制：消费者仅能消费 HW 以下的消息，避免消费到未同步给所有副本的消息（若原 Leader 故障，这些消息可能未被 Follower 同步，会丢失）；<br>故障恢复同步：若 Follower 故障后重启，会先向 Leader 发送 FetchRequest，拉取自身 LEO 到 Leader 当前 LEO 之间的所有消息，同步完成后才加入 ISR；<br>生产者确认机制：生产者配置 acks=-1 时，消息需被 ISR 中至少 min.insync.replicas 个副本确认（即这些副本的 LEO 已更新到该消息 offset），才算发送成功，确保消息已被多个副本同步。<br>（4）HW 落后 LEO 过多的影响<br>HW 落后 LEO 过多（即 Leader 的 LEO 远大于部分 Follower 的 LEO），会导致：<br>消息可见性延迟：消费者只能消费 HW 以下的消息，若 HW 长期落后 LEO，会导致消息写入后长时间无法被消费（如 Leader 写入 1000 条消息，Follower 仅同步 500 条，HW=500，消费者只能消费前 500 条）；<br>数据丢失风险：若 Leader 故障，新 Leader 从 ISR 中选举，HW 会成为新的消息可见上限，原 Leader 中 HW 以上的消息（未被 Follower 同步）会丢失；<br>ISR 收缩风险：若 Follower 长期落后 Leader（超过 replica.lag.time.max.ms），会被移出 ISR，导致 ISR 集合缩小，若 min.insync.replicas 配置为 2，且 ISR 中仅剩余 Leader 一个副本，会导致生产者 acks=-1 时消息发送失败（需至少 2 个副本确认）；<br>性能下降：Leader 需维护大量未同步的消息，且 Follower 追赶时会占用大量网络带宽和磁盘 IO，影响集群整体读写性能。<br>（5）解决方案<br>优化 Follower 同步配置：减小 replica.fetch.wait.max.ms（如设为 200 毫秒），让 Follower 更频繁拉取消息；增大 replica.fetch.min.bytes（如设为 1KB），避免 Follower 因消息量少而长期不同步；<br>提升集群网络性能：避免 Broker 之间网络带宽瓶颈（如使用万兆网卡、分开存储和业务网络）；<br>调整副本数和 min.insync.replicas：副本数至少 3，min.insync.replicas 设为 2，平衡可用性和一致性；<br>监控 HW/LEO 差距：通过 Kafka 监控指标（如 kafka.server:type=ReplicaManager,name=UnderReplicatedPartitions）跟踪同步延迟，及时扩容或排查故障。<br>（6）RocketMQ 的副本同步机制<br>RocketMQ 采用 “主从复制” 机制，与 Kafka 的 HW/LEO 机制不同：<br>同步机制：<br>Master 写入：生产者发送消息到 Master，Master 写入 CommitLog 后，根据复制模式决定是否等待 Slave 同步；<br>Slave 同步：Slave 通过 HAConnection 向 Master 拉取数据，同步到本地 CommitLog 和 ConsumeQueue；<br>同步确认：同步复制模式下，Master 需等待所有 Slave 确认后才返回成功给生产者。<br>数据一致性保障：<br>同步复制：Master 等待所有 Slave 同步完成，保证强一致性（类似 Kafka 的 acks=-1 + min.insync.replicas）；<br>异步复制：Master 立即返回，Slave 异步同步，可能出现数据丢失（类似 Kafka 的 acks=1）；<br>刷盘策略：通过 flushDiskType 配置（SYNC_FLUSH 同步刷盘、ASYNC_FLUSH 异步刷盘），进一步保证数据持久化。<br>与 Kafka HW/LEO 的对比：<br>| 对比维度 | Kafka HW/LEO | RocketMQ 主从复制 |<br>|———|————-|——————|<br>| 同步指标 | LEO（日志末尾偏移量）+ HW（高水位线） | 同步确认（同步复制）或异步拉取（异步复制） |<br>| 可见性控制 | 消费者只能消费 HW 以下的消息 | 消费者可消费 Master 已写入的消息（同步复制保证已同步） |<br>| 数据一致性 | 通过 HW 机制保证，可能短暂不可见 | 同步复制保证强一致性，异步复制可能丢失 |<br>| 故障恢复 | 从 ISR 中选举新 Leader，HW 成为可见上限 | Slave 切换为 Master，继续提供服务 |<br>| 性能影响 | HW 落后 LEO 时影响消息可见性 | 同步复制延迟高，异步复制性能好 |</p><p>为什么会有这种差别？<br>架构设计不同：<br>Kafka：多副本架构（通常 3 个副本），通过 ISR 动态维护同步副本集合，HW 机制平衡性能和一致性；<br>RocketMQ：主从架构（通常 2 个副本），Master-Slave 关系固定，通过同步/异步复制模式选择一致性级别。<br>一致性保证方式不同：<br>Kafka：通过 HW 机制保证，消息写入后需等待所有 ISR 副本同步，HW 提升后消息才可见，可能短暂延迟；<br>RocketMQ：同步复制模式下，消息写入后立即等待 Slave 同步，同步完成后消息即可见，无延迟但性能较低。<br>面试加分点：<br>举例说明故障场景：Kafka 中，原 Leader 的 LEO=100，Follower A 的 LEO=90，Follower B 的 LEO=80，HW=80；若 Leader 故障，选举 Follower A 为新 Leader，新的 HW=min(90,80)=80，消费者仍只能消费到 80 偏移量，Follower A 中 81-90 的消息需等待 Follower B 同步后，HW 才会提升；RocketMQ 中，若 Master 故障，Slave 切换为 Master，继续提供服务，但异步复制模式下可能丢失未同步的消息；<br>提到 leader.replication.throttled.rate 和 follower.replication.throttled.rate：限制副本同步时的带宽，避免影响业务读写；RocketMQ 通过 haSendHeartbeatInterval 配置控制主从同步频率，平衡同步性能和实时性。<br>8. 题目：Kafka 为什么不支持单分区多 Leader？如果要实现分区级别的负载均衡，有什么替代方案？<br>核心考点：分区架构设计、负载均衡逻辑、可用性权衡<br>详细答案：<br>（1）Kafka 不支持单分区多 Leader 的核心原因<br>Kafka 的设计原则是 “分区内消息有序 + 数据一致性”，单分区多 Leader 会破坏这两个核心目标：<br>破坏消息顺序性：Kafka 保证 “分区内消息有序”（生产者按顺序发送，消费者按顺序消费），若单分区有多个 Leader，多个生产者同时向不同 Leader 写入消息，会导致消息在分区内乱序（如生产者 1 发送消息 A，生产者 2 发送消息 B，最终分区内 B 在 A 之前）；<br>数据一致性冲突：多个 Leader 同时写入数据，需同步给所有 Follower，若网络分区导致 Leader 之间无法通信，会出现 “双写” 问题（不同 Leader 写入不同消息），后续网络恢复后无法合并数据，导致数据不一致；<br>消费逻辑混乱：消费者订阅分区时，需明确从哪个 Leader 拉取消息，若多个 Leader 同时提供服务，消费者可能重复消费或漏消费消息（如同一消息在多个 Leader 中存在）；<br>实现复杂度极高：需设计复杂的分布式锁机制保证 Leader 之间的互斥写入，且同步机制会大幅增加 Broker 开销，降低集群吞吐量（违背 Kafka 高并发设计目标）。<br>（2）分区级负载均衡的替代方案<br>单分区的性能上限由单个 Broker 的 CPU、磁盘 IO、网络带宽决定（如单分区写入吞吐量约 10-30MB/s），若单分区压力过大，需通过以下方案实现负载均衡：<br>增加分区数（核心方案）：<br>原理：将 Topic 的分区数扩容（如从 10 个扩容到 20 个），让更多 Broker 参与该 Topic 的读写，分散单分区压力；<br>注意事项：<br>分区数扩容后，原有分区数据不会自动迁移，需通过 kafka-reassign-partitions.sh 工具手动迁移，确保数据均匀分布；<br>分区数不能减少（Kafka 不支持删除分区），因此需提前规划（如按业务峰值吞吐量的 2 倍设计分区数）；<br>消费端需支持动态感知分区数变化（如启用 partition.assignment.strategy=Sticky 策略）。<br>Topic 拆分（业务层面）：<br>原理：将高压力的 Topic 按业务维度拆分为多个 Topic（如将 “订单 Topic” 拆分为 “北京订单 Topic”“上海订单 Topic”），每个 Topic 独立配置分区数，分散负载；<br>适用场景：业务有明显地域、类型拆分维度，且消费者仅需消费部分业务数据。<br>读写分离（只读副本）：<br>原理：Kafka 2.4+ 版本支持 “只读副本”（replica.type=consumer_fenced），只读副本仅同步 Leader 数据，不参与 Leader 选举和写入，仅提供读取服务；<br>实现逻辑：生产者写入 Leader 副本，消费者可从 Leader 或只读副本拉取消息，分散读取压力；<br>注意事项：只读副本不影响 ISR 集合和数据一致性，需通过 consumer.rack.aware.assignment.enable 配置让消费者优先从本地机架的只读副本读取，降低网络开销。<br>数据分片（应用层面）：<br>原理：应用层按消息 key 进行分片，将不同 key 的消息发送到不同的 Topic 或分区（如按用户 ID 哈希分片），确保单 Topic / 分区的消息量可控；<br>适用场景：消息 key 分布均匀，且无需跨分片有序性（如用户行为日志）。<br>（3）RocketMQ 的 Queue 机制<br>RocketMQ 采用 “Topic + Queue” 的架构，与 Kafka 的 “Topic + Partition” 类似但实现不同：<br>Queue 特点：<br>逻辑队列：Queue 是逻辑概念，所有 Queue 的消息物理上存储在同一个 CommitLog 中，通过 ConsumeQueue 分离；<br>Queue 数量：每个 Topic 默认 4 个 Queue，可通过 createTopic 命令指定 Queue 数量（类似 Kafka 的分区数）；<br>负载均衡：消费者通过负载均衡策略分配 Queue，一个 Queue 只能被一个消费者消费（类似 Kafka 的分区消费规则）。<br>与 Kafka 分区的对比：<br>| 对比维度 | Kafka Partition | RocketMQ Queue |<br>|———|—————-|—————|<br>| 存储方式 | 分区独立存储（每个分区独立的 .log 文件） | 统一存储（所有 Queue 共享 CommitLog） |<br>| 物理隔离 | 分区数据物理隔离 | Queue 数据逻辑隔离（通过 ConsumeQueue） |<br>| 扩展性 | 分区数可动态增加（不能减少） | Queue 数量可动态增加（不能减少） |<br>| 消费规则 | 一个分区只能被一个消费者消费 | 一个 Queue 只能被一个消费者消费 |<br>| 顺序性 | 分区内有序 | Queue 内有序（全局有序需单 Queue） |</p><p>为什么 RocketMQ 也不支持单 Queue 多 Master？<br>与 Kafka 类似的原因：<br>保证顺序性：Queue 内消息有序，多个 Master 同时写入会导致乱序；<br>数据一致性：多个 Master 同时写入会导致数据冲突，无法保证一致性；<br>实现复杂度：需要复杂的分布式锁和同步机制，性能开销大。<br>替代方案：<br>增加 Queue 数量：通过 updateTopic 命令增加 Queue 数量，分散负载（类似 Kafka 增加分区数）；<br>Topic 拆分：按业务维度拆分为多个 Topic，每个 Topic 独立配置 Queue 数量；<br>读写分离：Master 负责写入，Slave 可提供只读服务（RocketMQ 4.5+ 支持）。<br>面试加分点：<br>提到 Kafka 未来可能的优化方向：如支持 “分区分片”（将单个分区拆分为多个子分片，每个子分片有独立 Leader），但目前仍未落地；RocketMQ 通过增加 Queue 数量实现负载均衡，Queue 数量建议为消费者数量的整数倍；<br>结合性能测试数据：Kafka 单分区写入吞吐量受限于磁盘 IO（机械硬盘约 10MB/s，SSD 约 30MB/s）；RocketMQ 单 Queue 写入吞吐量受限于 CommitLog 的顺序写性能（所有 Queue 共享 CommitLog，性能更高）；<br>生产环境实践：Kafka 通过 kafka-topics.sh –alter –topic xxx –partitions 20 扩容分区，以及通过 kafka-reassign-partitions.sh 生成分区迁移计划；RocketMQ 通过 updateTopic 命令增加 Queue 数量，通过 mqadmin 工具管理 Topic 和 Queue。<br>9. 题目：Kafka 的 Topic 分区数如何规划？过多或过少会有什么问题？结合业务场景（如高并发写入、大数据量存储）说明设计思路。<br>核心考点：分区规划实践、性能优化、业务适配<br>详细答案：<br>Kafka 分区数的规划核心是 “平衡吞吐量、可用性、存储成本”，需结合业务吞吐量、单 Broker 性能、存储需求、消费端并行度等因素综合考虑，无绝对标准，但有明确的设计原则和避坑点。<br>（1）分区数规划的核心原则<br>吞吐量导向：单分区的写入吞吐量约 10-30MB/s（机械硬盘）或 30-100MB/s（SSD），读取吞吐量约 50-200MB/s； Topic 总吞吐量 = 单分区吞吐量 × 分区数，因此需根据业务峰值吞吐量估算分区数（建议预留 2-3 倍冗余，应对流量波动）；<br>消费端并行度：消费者组的最大并行消费数 = 分区数（一个分区仅能被一个消费者消费），因此分区数需 ≥ 消费者组内的消费者数，否则部分消费者会空闲；<br>存储成本：每个分区的副本会分散存储在不同 Broker 上（副本数默认 3），分区数越多，存储开销越大（如 100 个分区、3 个副本，需占用 300 个分区的存储资源）；<br>可用性：分区数越多，Broker 故障时需要迁移的分区数越多，Leader 选举耗时越长，集群恢复速度越慢；<br>运维成本：分区数过多会增加监控、配置管理、故障排查的复杂度（如 1 万个分区的集群，排查某分区故障耗时远高于 100 个分区）。<br>（2）过多或过少分区的问题<br>场景    具体问题<br>分区数过少    1. 吞吐量瓶颈：单分区无法承载业务峰值流量，导致消息积压；<br>2. 消费并行度不足：消费者组内消费者数超过分区数，部分消费者空闲；<br>3. 单 Broker 压力过大：分区集中在少数 Broker 上，导致这些 Broker 的 CPU、IO、网络过载；<br>4. 扩容困难：后续需扩容分区时，需手动迁移数据，且可能导致消息乱序（若按 key 分区）。<br>分区数过多    1. 存储开销大：副本数 × 分区数过多，占用大量磁盘空间；<br>2. 集群恢复慢：Broker 故障时，需选举大量 Leader 分区，导致集群抖动时间长；<br>3. 元数据膨胀：Kafka 集群元数据（分区信息、副本分布）存储在 Controller 中，过多分区会导致元数据同步延迟；<br>4. 消费端压力大：消费者需同时处理大量分区的消息，上下文切换开销大，可能导致消费延迟；<br>5. 日志清理效率低：每个分区都有独立的日志分段，过多分区会导致 LogCleaner 线程清理压力过大。<br>（3）不同业务场景的设计思路<br>场景 1：高并发写入（如日志收集、实时监控数据）<br>特点：消息量大（峰值每秒 10 万 +）、单条消息小（1KB 以下）、无需严格顺序（或按 key 顺序）、消费端并行度要求高；<br>规划思路：<br>按吞吐量估算：假设单分区写入吞吐量 20MB/s，业务峰值 100MB/s，则分区数 = 100MB/s ÷ 20MB/s = 5 个，预留冗余后设为 10 个；<br>消费端适配：消费者组内消费者数设为 10 个，确保每个消费者处理 1 个分区，最大化并行度；<br>副本数配置：3 个副本（保证高可用），存储选择 SSD（提升单分区吞吐量）。<br>场景 2：大数据量存储（如历史订单数据、业务归档数据）<br>特点：数据量大（TB 级）、写入吞吐量中等、读取频率低、需长期保留（如 30 天）；<br>规划思路：<br>按存储容量估算：假设每个分区最大存储 50GB 数据（避免单个分区文件过大），总数据量 1TB，则分区数 = 1TB ÷ 50GB = 20 个，副本数 2 个（降低存储成本）；<br>日志保留配置：设置 log.retention.bytes=50GB（单分区最大存储）和 log.retention.days=30（保留 30 天）；<br>分区分布：确保分区均匀分布在所有 Broker 上，避免单个 Broker 存储压力过大。<br>场景 3：低延迟读写（如实时推荐、支付回调）<br>特点：消息量中等、单条消息较大（1-10KB）、读写延迟要求低（毫秒级）、需严格顺序（如按用户 ID 分区）；<br>规划思路：<br>按延迟要求估算：单分区读写延迟 ≤ 10ms，消费者并行度需 5 个，则分区数设为 5-8 个（预留少量冗余）；<br>避免过度分区：过多分区会导致 Leader 选举耗时增加，影响低延迟目标；<br>配置优化：启用 log.flush.interval.messages=1000（每 1000 条消息刷盘），减少刷盘延迟；禁用压缩（或使用 LZ4 快速压缩算法），降低读写 CPU 开销。<br>场景 4：业务拆分明确（如多地域业务）<br>特点：业务按地域、部门拆分，不同业务模块消息量差异大；<br>规划思路：<br>按业务拆分 Topic：每个地域 / 部门独立 Topic，避免单个 Topic 分区数过多；<br>分区数差异化：高流量业务 Topic 设 10-20 个分区，低流量业务 Topic 设 3-5 个分区；<br>分区副本绑定机架：通过 rack.aware.assignment.enable=true 配置，让分区副本分布在不同机架的 Broker 上，提升容灾能力。<br>（4）规划步骤总结<br>估算业务峰值吞吐量（写入 + 读取）；<br>确定单分区吞吐量（基于硬件性能：SSD / 机械硬盘、CPU 核心数）；<br>初步计算分区数 = 峰值吞吐量 ÷ 单分区吞吐量 × 冗余系数（2-3）；<br>结合消费端并行度（消费者数 ≤ 分区数）调整；<br>考虑存储成本和运维成本，最终确定分区数（建议单个 Topic 分区数不超过 100，集群总分区数不超过 1 万个）。<br>（5）RocketMQ 的 Queue 数量规划<br>RocketMQ 的 Queue 数量规划原则与 Kafka 分区数规划类似，但需考虑统一存储的特点：<br>规划原则：<br>吞吐量导向：所有 Queue 共享 CommitLog，单 Broker 写入吞吐量约 50-100MB/s（SSD），Queue 数量主要影响消费并行度；<br>消费并行度：消费者组的最大并行消费数 = Queue 数量（一个 Queue 只能被一个消费者消费），因此 Queue 数量需 ≥ 消费者数；<br>存储成本：所有 Queue 共享 CommitLog，存储成本与 Queue 数量无关，主要取决于消息总量和保留时间；<br>可用性：Queue 数量越多，Master 故障时影响范围越小（仅影响部分 Queue），但管理复杂度增加。<br>与 Kafka 分区数规划的对比：<br>| 对比维度 | Kafka 分区数 | RocketMQ Queue 数量 |<br>|———|————|——————-|<br>| 存储影响 | 分区数越多，存储开销越大（每个分区独立存储） | Queue 数量不影响存储（所有 Queue 共享 CommitLog） |<br>| 写入性能 | 分区数越多，并行写入能力越强 | Queue 数量不影响写入性能（统一写入 CommitLog） |<br>| 消费性能 | 分区数 = 消费并行度上限 | Queue 数量 = 消费并行度上限 |<br>| 管理复杂度 | 分区数越多，文件数越多，管理越复杂 | Queue 数量越多，ConsumeQueue 文件越多，但文件小易管理 |</p><p>为什么会有这种差别？<br>存储架构不同：<br>Kafka：分区独立存储，每个分区有独立的日志文件，分区数越多，文件数越多，存储和管理开销越大；<br>RocketMQ：统一存储架构，所有 Queue 共享 CommitLog，Queue 数量不影响存储开销，仅影响 ConsumeQueue 文件数量（文件小，影响小）。<br>性能影响不同：<br>Kafka：分区数直接影响写入并行度（每个分区独立写入），分区数越多，写入吞吐量越高；<br>RocketMQ：Queue 数量不影响写入性能（所有 Queue 统一写入 CommitLog），主要影响消费并行度。<br>规划建议：<br>Kafka：根据写入吞吐量和消费并行度规划分区数，建议单个 Topic 分区数不超过 100；<br>RocketMQ：主要根据消费并行度规划 Queue 数量，建议 Queue 数量为消费者数量的整数倍（如 4、8、16），单个 Topic Queue 数量不超过 64。<br>面试加分点：<br>提到分区重分配工具：Kafka 通过 kafka-reassign-partitions.sh 用于分区扩容后的数据迁移，确保分区均匀分布；RocketMQ 通过 updateTopic 命令增加 Queue 数量，无需数据迁移（所有 Queue 共享 CommitLog）；<br>结合监控指标：Kafka 通过 kafka.server:type=BrokerTopicMetrics,name=BytesInPerSec（写入吞吐量）和 BytesOutPerSec（读取吞吐量）监控分区负载；RocketMQ 通过 BrokerStatsManager 监控 Queue 的消费延迟和积压情况；<br>生产环境案例：Kafka 日志收集 Topic 按 20 个分区规划，支撑每秒 5 万条消息写入；支付 Topic 按 8 个分区规划，确保消费延迟 ≤ 50ms；RocketMQ 订单 Topic 按 16 个 Queue 规划，支撑每秒 10 万条消息写入，消费延迟 ≤ 30ms。<br>10. 题目：Kafka 与其他消息队列（RabbitMQ/RocketMQ）的架构差异是什么？为什么 Kafka 更适合大数据量、高并发场景？<br>核心考点：MQ 架构对比、场景适配、底层优化<br>详细答案：<br>（1）Kafka 与 RabbitMQ/RocketMQ 的核心架构差异<br>对比维度    Kafka    RabbitMQ    RocketMQ<br>设计定位    高吞吐量、大数据量的日志收集、数据同步、流处理    低延迟、高可靠的业务消息传递（如订单通知、秒杀）    平衡吞吐量与延迟，支持复杂业务场景（如分布式事务、定时消息）<br>存储模型    日志文件分段存储（.log+.index），顺序写磁盘，支持海量数据持久化    内存 + 磁盘存储，消息存储在队列中，支持多种队列类型（直连 / 主题 / 扇形）    日志文件存储（类似 Kafka），支持消息过滤、定时投递<br>分区模型    Topic 分区 + 副本机制，分区内有序，支持水平扩展    无分区概念，队列是最小存储单位，扩展依赖队列拆分    Topic 分区 + 副本机制，支持全局有序（通过单分区）和局部有序<br>网络模型    Reactor 模式（Selector + 多线程），支持百万级并发连接    AMQP 协议，基于 TCP 连接，并发连接数有限（万级）    Netty 基于 NIO，支持百万级并发连接<br>消息投递语义    支持 At-Least-Once/At-Most-Once/Exactly-Once（事务 + 幂等性）    支持 At-Least-Once/At-Most-Once，Exactly-Once 需通过业务幂等性实现    支持 At-Least-Once/At-Most-Once/Exactly-Once（事务 + 幂等性）<br>核心优势    高吞吐量（十万级 / 秒）、低存储成本、支持流处理（Kafka Streams）    低延迟（毫秒级）、协议成熟（AMQP）、生态丰富（支持多种客户端）    功能全面（事务、定时、重试）、国产化适配好、支持大规模集群<br>劣势    延迟略高（毫秒级）、复杂业务功能弱（如定时消息需自定义）    吞吐量低（万级 / 秒）、大数据量存储成本高    生态不如 Kafka/RabbitMQ 成熟、社区活跃度略低<br>（2）Kafka 更适合大数据量、高并发场景的核心原因<br>Kafka 的设计从底层到架构都围绕 “高吞吐量、大数据量” 优化，核心优势体现在以下 5 点：<br>顺序写磁盘 + 页缓存优化：<br>Kafka 的日志文件采用 “顺序写”（避免随机 IO 的高开销），磁盘顺序写速度接近内存写速度（机械硬盘顺序写约 100MB/s，SSD 约 500MB/s）；<br>利用操作系统页缓存（Page Cache），消息写入时先写入页缓存，由操作系统后台异步刷盘，减少磁盘 IO 阻塞；读取时优先从页缓存读取，命中率高（大数据量场景下页缓存利用率高）。<br>零拷贝技术（Zero-Copy）：<br>Kafka 利用 Linux 的 sendfile() 系统调用实现零拷贝，消息从磁盘文件到网络 socket 无需经过用户态和内核态的数据拷贝（传统方式：磁盘→内核缓存→用户缓存→内核 socket 缓存→网络，需 4 次拷贝）；<br>零拷贝减少了 CPU 开销和内存带宽占用，让 Kafka 单 Broker 吞吐量可达 100MB/s 以上。<br>分区 + 副本的水平扩展架构：<br>Topic 分区后，数据分散在多个 Broker 上，写入和读取可并行处理（如 10 个分区的 Topic，吞吐量是单分区的 10 倍）；<br>副本机制确保数据高可用的同时，不影响吞吐量（Follower 同步消息不占用 Leader 的写入资源）。<br>批量读写 + 压缩优化：<br>生产端支持批量发送消息（batch.size 配置，默认 16KB），减少网络请求次数；消费端支持批量拉取消息，提升消费效率；<br>支持消息压缩（GZIP、Snappy、LZ4），批量压缩后减少网络传输和存储开销（大数据量场景下压缩比可达 3-10 倍）。<br>轻量化的消息结构：<br>Kafka 的消息头仅包含必要信息（offset、时间戳、key 长度、value 长度），消息体无额外冗余，序列化 / 反序列化开销小；<br>相比 RabbitMQ 的 AMQP 协议（消息头包含大量元数据），Kafka 的消息结构更简洁，处理速度更快。<br>（3）RocketMQ 的详细架构特点<br>存储模型：<br>CommitLog：所有 Topic 的消息统一存储在 CommitLog 中，顺序写磁盘，充分利用顺序 IO 性能；<br>ConsumeQueue：每个 Queue 对应一个 ConsumeQueue 文件，存储消息在 CommitLog 中的位置，文件小可全量加载内存；<br>IndexFile：按消息 key 和时间戳建立索引，支持按 key 和时间范围查询。<br>网络模型：<br>Netty 框架：基于 Netty 的 NIO 模型，支持百万级并发连接，类似 Kafka 的 Reactor 模式；<br>长连接：生产者和消费者与 Broker 建立长连接，减少连接建立开销；<br>异步通信：支持同步和异步两种通信模式，异步模式性能更高。<br>功能特性：<br>事务消息：支持分布式事务消息，通过 TransactionListener 实现本地事务和消息发送的协调；<br>定时消息：支持延迟消息和定时消息（通过 scheduleTime 字段），适合定时任务场景；<br>消息过滤：支持 Tag 过滤和 SQL 过滤，消费者可订阅特定 Tag 或 SQL 条件的消息；<br>顺序消息：支持全局顺序（单 Queue）和局部顺序（按 key 分区），保证消息有序消费。<br>（4）Kafka vs RocketMQ 详细对比<br>| 对比维度 | Kafka | RocketMQ |<br>|———|——-|———-|<br>| 存储架构 | 分区独立存储 | 统一存储（CommitLog）+ 逻辑队列（ConsumeQueue） |<br>| 写入性能 | 分区并行写入，单 Broker 50-100MB/s | 统一写入 CommitLog，单 Broker 50-100MB/s |<br>| 读取性能 | 按分区读取，支持批量拉取 | 按 Queue 读取，ConsumeQueue 可全量加载内存 |<br>| 索引机制 | 稀疏索引（.index + .timeindex） | 稠密索引（ConsumeQueue）+ 哈希索引（IndexFile） |<br>| 查询能力 | 支持按 offset 和时间戳查询 | 支持按 offset、key、时间范围查询 |<br>| 事务支持 | Kafka 0.11+ 支持事务 | RocketMQ 4.3+ 支持事务消息 |<br>| 定时消息 | 不支持（需自定义） | 原生支持延迟消息和定时消息 |<br>| 消息过滤 | 不支持（需客户端过滤） | 支持 Tag 过滤和 SQL 过滤 |<br>| 顺序消息 | 分区内有序 | Queue 内有序（全局有序需单 Queue） |<br>| 流处理 | 支持 Kafka Streams | 不支持（需集成 Flink/Spark） |<br>| 生态成熟度 | 全球广泛使用，生态成熟 | 国内广泛使用，生态相对成熟 |</p><p>为什么 Kafka 更适合大数据量、高并发场景？<br>顺序写磁盘 + 页缓存：Kafka 的分区独立存储，每个分区顺序写，充分利用顺序 IO 性能；RocketMQ 的统一存储也采用顺序写，性能相当。<br>零拷贝技术：两者都支持零拷贝（sendfile），减少 CPU 开销。<br>分区并行：Kafka 的分区并行写入，分区数越多，吞吐量越高；RocketMQ 的 Queue 数量不影响写入性能（统一写入），但消费并行度受 Queue 数量限制。<br>批量读写：两者都支持批量发送和批量拉取，减少网络请求次数。<br>为什么 RocketMQ 更适合复杂业务场景？<br>功能全面：RocketMQ 原生支持事务消息、定时消息、消息过滤等功能，无需额外开发；<br>统一存储：所有消息统一存储在 CommitLog，写入性能高，但读取需要通过 ConsumeQueue 定位；<br>国产化：RocketMQ 是阿里开源，国内使用广泛，文档和社区支持好。<br>（5）场景适配总结<br>选 Kafka：日志收集、大数据同步、流处理、高并发写入（十万级 / 秒）、大数据量存储（TB 级）场景；<br>选 RabbitMQ：低延迟（毫秒级）、复杂路由（如扇形分发、主题路由）、业务通知（如订单短信）场景；<br>选 RocketMQ：国内业务、分布式事务、定时消息、消息过滤、平衡吞吐量与延迟的复杂业务场景。<br>面试加分点：<br>提到 Kafka Streams：内置流处理能力，无需依赖外部流处理框架（如 Flink），适合简单的实时数据处理场景；RocketMQ 需集成 Flink/Spark 实现流处理；<br>结合性能测试数据：Kafka 单 Broker 写入吞吐量可达 50-100MB/s，RabbitMQ 约 1-5MB/s，RocketMQ 约 50-100MB/s（统一存储优势）；<br>生产环境选型建议：大型互联网公司通常混合使用（如 Kafka 做日志收集和流处理，RabbitMQ 做业务通知，RocketMQ 做核心业务消息和定时任务）。<br>三、性能优化与调优<br>11. 题目：Kafka 生产端的吞吐量优化手段有哪些？（从批量发送、压缩、缓冲区、分区策略等角度分析）<br>核心考点：生产端优化实践、底层原理、参数配置<br>详细答案：<br>Kafka 生产端吞吐量优化的核心是 “减少网络请求次数、降低 IO 开销、提升并行度”，结合底层机制和参数配置，从以下 6 个角度展开：<br>（1）批量发送优化（核心手段）<br>原理：将多条消息合并为一个批次发送，减少网络请求次数（网络请求的 latency 是生产端的主要瓶颈之一）；<br>关键配置：<br>batch.size=16384（默认 16KB）：单个批次的最大字节数，超过该值则立即发送；<br>优化建议：根据消息大小调整，如单条消息 1KB，可设为 64KB（64 条消息一批），平衡批次大小和延迟；<br>linger.ms=0（默认 0ms）：消息在缓冲区的最大停留时间，即使未达到 batch.size，到时间后也会发送；<br>优化建议：设为 5-10ms，允许生产者积累更多消息组成批次，提升批量率（牺牲少量延迟换取高吞吐量）；<br>注意事项：linger.ms 不宜过大（如超过 50ms），否则会导致消息延迟过高，适用于对延迟不敏感的场景（如日志收集）。<br>（2）消息压缩优化<br>原理：对批次消息进行压缩，减少网络传输量和 Broker 存储开销，压缩比越高，吞吐量提升越明显；<br>关键配置：<br>compression.type=none（默认无压缩）：支持 gzip/snappy/lz4/zstd 四种压缩算法；<br>选型建议：<br>追求压缩比：gzip（压缩比最高，但 CPU 开销大），适合消息量大、网络带宽紧张的场景；<br>平衡性能和压缩比：lz4/snappy（CPU 开销小，压缩比中等），适合大多数高并发场景；<br>极致性能：zstd（Kafka 2.1+ 支持，压缩比和性能均优于 lz4）；<br>compression.level（可选）：压缩级别（1-9），级别越高压缩比越高，但 CPU 开销越大，默认使用算法默认级别；<br>底层优化：压缩是按批次进行的，批次越大，压缩比越高（相同算法下，100 条消息的批次压缩比远高于 10 条消息的批次），因此需配合 batch.size 和 linger.ms 配置。<br>（3）缓冲区优化<br>原理：生产者内部维护两个缓冲区（发送缓冲区 + 记录缓冲区），缓冲区大小不足会导致频繁阻塞或刷盘，影响吞吐量；<br>关键配置：<br>buffer.memory=33554432（默认 32MB）：生产者用于缓存消息的总内存大小，超过该值后，生产者会阻塞或抛出异常（取决于 block.on.buffer.full，Kafka 2.0+ 后默认抛出 BufferExhaustedException）；<br>优化建议：根据并发量调整，如高并发场景下设为 64MB 或 128MB，避免缓冲区溢出；<br>max.block.ms=60000（默认 60 秒）：生产者阻塞时的最大等待时间，超时后抛出异常；<br>优化建议：设为 10-30 秒，避免长时间阻塞影响应用可用性。<br>（4）分区策略优化<br>原理：合理的分区策略确保消息均匀分布在多个分区，避免单分区成为吞吐量瓶颈；<br>关键配置：<br>partitioner.class：指定分区器类，默认 DefaultPartitioner（按 key 哈希分区，无 key 则轮询）；<br>优化建议：<br>有 key 场景：确保 key 分布均匀（如用户 ID、订单 ID 哈希），避免 key 集中导致单分区消息过多；<br>无 key 场景：使用默认轮询策略，确保消息均匀分布；<br>自定义分区策略：若业务有特殊需求（如按地域分区），可实现 Partitioner 接口，重写 partition() 方法；<br>增加分区数：分区数越多，并行写入能力越强（需配合 Broker 扩容），但需避免分区数过多（参考第 9 题）。<br>（5）网络优化<br>原理：减少网络延迟和带宽占用，提升消息发送效率；<br>关键配置：<br>max.in.flight.requests.per.connection=5（默认 5）：单个连接上允许同时发送的未确认请求数，增加该值可提升并行度；<br>优化建议：设为 10-20（需确保 Broker 能承受），但启用幂等性生产时建议设为 1（避免消息乱序）；<br>request.timeout.ms=30000（默认 30 秒）：消息发送超时时间，超时后会重试；<br>优化建议：设为 10-15 秒，避免长时间等待；<br>使用长连接：生产者默认使用长连接，避免频繁建立 / 关闭 TCP 连接的开销；<br>网络带宽优化：使用万兆网卡、分开存储和业务网络，避免网络瓶颈。<br>（6）其他优化<br>启用幂等性生产（enable.idempotence=true）：避免消息重复发送，减少 Broker 处理重复消息的开销；<br>调整重试参数（retries=Integer.MAX_VALUE）：确保网络抖动时消息不丢失，同时配合 retry.backoff.ms=100（重试间隔），避免频繁重试；<br>异步发送：使用 producer.send() 的异步回调方式（Callback），避免同步发送导致的阻塞；<br>硬件优化：Broker 使用 SSD 磁盘（提升单分区写入吞吐量）、多核心 CPU（支撑压缩 / 解压缩并行处理）。<br>（7）RocketMQ 生产端优化手段<br>RocketMQ 生产端优化与 Kafka 类似，但实现细节有差异：<br>批量发送优化：<br>批量大小：通过 sendMsgTimeout 和 compressMsgBodyOverHowmuch 配置控制批量发送，默认单条发送，可设置批量大小（如 4KB、8KB）；<br>批量发送 API：使用 sendBatch() 方法批量发送消息，减少网络请求次数。<br>消息压缩优化：<br>压缩阈值：通过 compressMsgBodyOverHowmuch 配置（默认 4KB），超过该大小的消息自动压缩；<br>压缩算法：支持 LZ4、ZLIB 等压缩算法，压缩比和性能与 Kafka 类似。<br>网络优化：<br>连接池：生产者维护与 Broker 的长连接池，复用连接减少建立开销；<br>异步发送：使用 send() 方法的异步回调方式，避免同步发送导致的阻塞；<br>重试机制：通过 retryTimesWhenSendFailed 配置重试次数，确保消息不丢失。<br>与 Kafka 生产端优化的对比：<br>| 对比维度 | Kafka | RocketMQ |<br>|———|——-|———-|<br>| 批量发送 | batch.size + linger.ms | sendBatch() API + 批量大小配置 |<br>| 消息压缩 | compression.type（批次压缩） | compressMsgBodyOverHowmuch（单条压缩） |<br>| 缓冲区 | buffer.memory（32MB 默认） | 无独立缓冲区配置 |<br>| 分区策略 | partitioner.class | MessageQueueSelector（Queue 选择器） |<br>| 网络优化 | max.in.flight.requests | 连接池 + 异步发送 |</p><p>为什么会有这种差别？<br>API 设计不同：<br>Kafka：通过配置参数控制批量发送和压缩，客户端自动批量；<br>RocketMQ：提供显式的批量发送 API（sendBatch()），更灵活但需要客户端实现批量逻辑。<br>压缩时机不同：<br>Kafka：按批次压缩，批次越大压缩比越高；<br>RocketMQ：按消息大小压缩，超过阈值自动压缩，适合大消息场景。<br>面试加分点：<br>结合监控指标：Kafka 通过 kafka.producer:type=ProducerMetrics,name=BatchSizeAvg（平均批次大小）、CompressionRate（压缩比）、RecordSendRate（发送速率）监控优化效果；RocketMQ 通过 ProducerStatsManager 监控发送速率、失败率等指标；<br>举例说明优化效果：Kafka 调整 batch.size=64KB、linger.ms=5ms、compression.type=lz4 后，生产端吞吐量从 1 万条 / 秒提升到 5 万条 / 秒；RocketMQ 使用 sendBatch() 批量发送和消息压缩后，吞吐量提升 3-5 倍；<br>避坑点：Kafka 的 linger.ms 设为 0 时，批量发送失效，吞吐量会大幅下降；RocketMQ 的批量发送需要客户端手动实现，需注意批量大小和延迟的平衡。<br>12. 题目：Kafka 消费端的积压问题如何排查？（从消费速度、分区数、Rebalance、消息大小等维度给出解决方案）<br>核心考点：消费端故障排查、性能优化、问题解决<br>详细答案：<br>Kafka 消费端积压（消息堆积在 Broker 中，消费速度 &lt; 生产速度）是高频问题，排查需遵循 “定位瓶颈 → 分析原因 → 针对性优化” 的流程，核心从 5 个维度展开：<br>（1）第一步：定位积压瓶颈（通过监控指标）<br>首先通过 Kafka 监控指标确认积压情况和瓶颈点：<br>核心指标：<br>kafka.consumer:type=ConsumerFetchMetrics,name=RecordsLagMax（最大分区积压消息数）：确认是否存在积压；<br>RecordsConsumedRate（消费速率）vs RecordsProducedRate（生产速率）：若消费速率持续低于生产速率，说明积压会持续扩大；<br>FetchRate（拉取频率）、FetchSizeAvg（平均拉取大小）：判断消费端拉取是否高效；<br>ConsumerLag（消费延迟）：消息从生产到被消费的时间差，延迟过高说明积压严重。<br>工具辅助：<br>使用 kafka-consumer-groups.sh 查看消费组积压：kafka-consumer-groups.sh –bootstrap-server xxx:9092 –group xxx –describe，关注 LAG 列（积压消息数）；<br>查看 Broker 日志（server.log），确认是否有消费端拉取超时、网络异常等报错。<br>（2）第二步：分析积压原因及解决方案<br>维度 1：消费速度过慢（最常见原因）<br>表现：消费速率远低于生产速率，单个消费者处理消息耗时过长；<br>常见原因：<br>消费端业务逻辑复杂（如数据库写入、远程调用）；<br>消费端单条消息处理时间长（如大消息解析、复杂计算）；<br>消费端线程数不足；<br>解决方案：<br>优化业务逻辑：<br>异步化处理：将非核心业务逻辑（如日志记录、通知发送）异步化，避免阻塞消费线程；<br>批量处理：数据库写入、远程调用改为批量操作（如批量插入 MySQL、批量调用 HTTP 接口），减少 IO 次数；<br>简化处理逻辑：移除不必要的计算、过滤操作，或将复杂计算迁移到流处理框架（如 Flink）；<br>增加消费并行度：<br>增加消费者线程数：在消费者实例中增加 max.poll.records（默认 500），每次拉取更多消息，同时增加消费线程池大小（如 Spring-Kafka 中 concurrency 配置）；<br>多实例部署：增加消费者组内的消费者实例数（需确保消费者数 ≤ 分区数，否则部分实例空闲）；<br>优化硬件和依赖：<br>消费端使用 SSD 磁盘（若需本地存储消息）、多核心 CPU；<br>优化数据库、缓存等依赖的性能（如 MySQL 索引优化、Redis 集群扩容），减少远程调用耗时。<br>维度 2：分区数不足（并行度瓶颈）<br>表现：消费者组内消费者数超过分区数，部分消费者空闲，消费并行度无法提升；<br>原因：分区数是消费并行度的上限（一个分区仅能被一个消费者消费）；<br>解决方案：<br>扩容 Topic 分区数：通过 kafka-topics.sh –alter –topic xxx –partitions 新分区数 扩容（需提前规划，分区数不能减少）；<br>分区重分配：使用 kafka-reassign-partitions.sh 工具将新增分区均匀分布在 Broker 上，避免单 Broker 压力过大；<br>业务拆分：将高积压的 Topic 按业务维度拆分为多个 Topic，分散分区压力。<br>维度 3：Rebalance 频繁（消费停顿）<br>表现：消费端频繁触发 Rebalance，期间消费停顿，导致积压扩大；<br>原因：消费者心跳超时、消费超时、成员变化（参考第 2 题）；<br>解决方案：<br>优化超时参数：<br>session.timeout.ms=30000（默认 45 秒）：设为 30-60 秒，避免网络抖动误判下线；<br>max.poll.interval.ms=300000（默认 5 分钟）：设为消费批次的 2-3 倍（如每次拉取 1000 条消息，处理耗时 1 分钟，则设为 180 秒）；<br>启用静态成员：配置 group.instance.id，消费者重启后仍能复用原有分区分配，避免 Rebalance；<br>正常退出消费者：调用 consumer.close() 方法，避免强制 kill 进程；<br>监控 Rebalance：通过 kafka.consumer:type=consumer-coordinator-metrics,name=RebalanceRate 指标告警，及时排查异常。<br>维度 4：消息大小过大（处理效率低）<br>表现：单条消息体积大（如 10MB 以上），消费端解析、传输耗时过长；<br>原因：Kafka 默认支持的最大消息大小为 1MB（message.max.bytes=1048576），大消息会导致：<br>网络传输慢：单条消息占用大量带宽，拉取耗时久；<br>解析耗时：大消息序列化 / 反序列化开销大；<br>批量发送失效：大消息难以组成批次，生产端吞吐量下降，间接导致消费端拉取效率低；<br>解决方案：<br>消息拆分：应用层将大消息拆分为多个小消息（如 10MB 消息拆分为 10 个 1MB 消息），消费端处理后合并；<br>调整 Broker 配置：临时增大 message.max.bytes、replica.fetch.max.bytes、fetch.max.bytes（消费端），支持大消息传输（不建议长期使用，大消息会影响集群性能）；<br>独立 Topic 存储：大消息单独使用一个 Topic，配置更大的分区大小和缓存，避免影响其他 Topic。<br>维度 5：消费端配置不合理（拉取效率低）<br>表现：消费端拉取频率低、拉取消息量少，导致消费速度慢；<br>常见配置问题：<br>max.poll.records=500（默认 500）：每次拉取的最大消息数过少；<br>fetch.min.bytes=1（默认 1B）：拉取消息的最小字节数，过小导致频繁拉取小批次消息；<br>fetch.max.wait.ms=500（默认 500ms）：拉取消息的最大等待时间，过长导致延迟；<br>解决方案：<br>调整拉取参数：<br>max.poll.records：根据消费端处理能力调整，如设为 1000-5000（确保单次拉取的消息能在 max.poll.interval.ms 内处理完）；<br>fetch.min.bytes：设为 1024-4096（1-4KB），让消费者积累更多消息后再拉取，提升批量率；<br>fetch.max.wait.ms：设为 100-200ms，平衡拉取效率和延迟；<br>启用增量拉取：Kafka 2.0+ 支持增量拉取（incremental.assignment.enable=true），Rebalance 时仅重新分配变化的分区，减少拉取开销。<br>维度 6：Broker 端瓶颈（影响消费拉取）<br>表现：Broker 磁盘 IO 高、网络带宽满，导致消费端拉取消息超时；<br>原因：Broker 同时承载高写入和高读取，资源不足；<br>解决方案：<br>Broker 扩容：增加 Broker 节点，分散分区存储和读写压力；<br>存储优化：使用 SSD 磁盘，提升磁盘 IO 速度；<br>网络优化：分开存储和业务网络，避免网络带宽瓶颈；<br>日志清理：及时清理过期日志，释放磁盘空间和 IO 资源。<br>（3）第三步：积压处理后的兜底方案<br>紧急扩容：临时增加消费者实例数（需确保分区数充足），快速消费积压消息；<br>跳过非核心消息：若积压消息中包含非核心数据（如日志），可临时修改消费端逻辑，跳过部分消息（需谨慎，避免数据丢失）；<br>数据迁移：将积压严重的分区数据迁移到空闲 Broker 上，提升拉取速度。<br>（4）RocketMQ 消费端积压排查与解决方案<br>RocketMQ 消费端积压问题的排查思路与 Kafka 类似，但实现细节有差异：<br>定位积压瓶颈：<br>监控指标：通过 RocketMQ 控制台或监控系统查看消费延迟（consumeDelay）、消费速率（consumeTps）、积压消息数（diff）等指标；<br>工具辅助：使用 mqadmin 命令查看消费组状态（mqadmin consumerProgress -g xxx），关注 diff 列（积压消息数）。<br>常见原因及解决方案：<br>消费速度过慢：<br>优化业务逻辑：异步化处理、批量处理、简化处理逻辑（与 Kafka 相同）；<br>增加消费并行度：增加消费者实例数（需确保消费者数 ≤ Queue 数量），或使用并发消费模式（ConsumeMessageConcurrently）；<br>优化硬件和依赖：使用 SSD、优化数据库和缓存性能。<br>Queue 数量不足：<br>扩容 Queue 数量：通过 updateTopic 命令增加 Queue 数量（类似 Kafka 扩容分区数）；<br>业务拆分：将高积压的 Topic 按业务维度拆分为多个 Topic。<br>负载均衡问题：<br>调整负载均衡策略：使用 AllocateMessageQueueAveragely 策略，确保 Queue 均匀分配；<br>避免频繁重平衡：RocketMQ 的负载均衡是客户端自主计算，无需服务端协调，但需避免消费者频繁上下线。<br>消息大小过大：<br>消息拆分：应用层将大消息拆分为多个小消息（与 Kafka 相同）；<br>调整配置：通过 maxMessageSize 配置支持大消息（默认 4MB，可调整）。<br>消费模式选择：<br>并发消费（ConsumeMessageConcurrently）：适合对顺序性要求不高的场景，消费速度快；<br>顺序消费（ConsumeMessageOrderly）：保证 Queue 内消息有序，但消费速度较慢，适合对顺序性要求高的场景。<br>与 Kafka 消费端积压的对比：<br>| 对比维度 | Kafka | RocketMQ |<br>|———|——-|———-|<br>| 积压监控 | RecordsLagMax、ConsumerLag | consumeDelay、diff |<br>| 并行度限制 | 分区数 = 消费并行度上限 | Queue 数量 = 消费并行度上限 |<br>| 负载均衡 | Rebalance 机制（服务端协调） | 客户端自主分配（无服务端协调） |<br>| 消费停顿 | Rebalance 期间全组暂停 | 无全局停顿，仅重新分配的 Queue 短暂停顿 |<br>| 消费模式 | 自动提交 / 手动提交 offset | 并发消费 / 顺序消费 |</p><p>为什么会有这种差别？<br>负载均衡机制不同：<br>Kafka：通过 Rebalance 机制统一分配分区，全组暂停等待分配完成，可能造成消费停顿；<br>RocketMQ：客户端自主计算 Queue 分配，无需服务端协调，避免全局停顿，但可能出现短暂不一致。<br>消费模式不同：<br>Kafka：通过 offset 提交机制控制消费语义（At-Least-Once/At-Most-Once）；<br>RocketMQ：通过消费模式（并发/顺序）和消息确认机制控制消费语义，更灵活但需要客户端实现。<br>面试加分点：<br>结合实战案例：Kafka 某日志 Topic 因分区数不足（10 个分区）导致积压，扩容到 30 个分区后，消费并行度提升 3 倍，积压 2 小时内清理完成；RocketMQ 某订单 Topic 因 Queue 数量不足（8 个 Queue）导致积压，扩容到 32 个 Queue 后，消费并行度提升 4 倍，积压 1 小时内清理完成；<br>提到消费端监控工具：Kafka 通过 Prometheus + Grafana 监控消费 lag、拉取速率、处理耗时等指标；RocketMQ 通过 RocketMQ 控制台或监控系统监控消费延迟、消费速率、积压消息数等指标；<br>避坑点：Kafka 增加 max.poll.records 时，需同步调整 max.poll.interval.ms，避免消费超时触发 Rebalance；RocketMQ 使用顺序消费时，需注意单 Queue 消费速度，避免成为瓶颈。<br>13. 题目：Kafka 的磁盘 I/O 是如何优化的？（结合顺序写、页缓存、零拷贝技术详细说明）<br>核心考点：磁盘 IO 优化原理、底层技术、源码关联<br>详细答案：<br>Kafka 作为高吞吐量消息队列，磁盘 IO 是核心瓶颈之一，其优化设计贯穿 “写入 - 存储 - 读取” 全流程，核心依赖 顺序写、页缓存、零拷贝 三大技术，配合日志分段和刷盘策略，实现磁盘 IO 效率最大化。<br>（1）核心优化 1：顺序写磁盘（写入优化核心）<br>传统消息队列的问题：大多数 MQ（如早期 RabbitMQ）采用 “随机写”（消息存储在队列中，需插入到队列中间或删除），磁盘随机写速度极慢（机械硬盘随机写约 100-200 IOPS，顺序写约 100MB/s）；<br>Kafka 的优化：将每个分区的消息存储为日志文件（.log），消息写入时仅在文件末尾追加（顺序写），避免随机 IO：<br>顺序写的优势：磁盘磁头无需频繁寻道和旋转，速度接近内存写（机械硬盘顺序写速度可达 100MB/s 以上，SSD 可达 500MB/s 以上）；<br>日志分段辅助：将大日志文件拆分为多个小 Segment（默认 1GB），避免单个大文件顺序写效率下降（大文件末尾追加时，文件系统元数据更新开销增大）；<br>源码关联：org.apache.kafka.logs.Log 类的 append() 方法，负责将消息追加到当前活跃 Segment 的 .log 文件末尾，底层通过 FileChannel 实现顺序写入。<br>（2）核心优化 2：页缓存（Page Cache）复用（存储 + 读取优化）<br>页缓存定义：操作系统为磁盘文件分配的内存缓存（Page Cache），用于缓存最近访问的文件数据，应用程序读取文件时优先从页缓存读取，写入时先写入页缓存，由操作系统后台异步刷盘；<br>Kafka 对页缓存的利用：<br>写入时：生产者发送的消息先写入 Kafka 应用层缓冲区，再通过 FileChannel.write() 写入页缓存（而非直接刷盘），减少磁盘 IO 阻塞（刷盘由操作系统 pdflush 线程异步完成，默认每隔 30 秒或页缓存达到阈值时刷盘）；<br>读取时：消费者拉取消息时，先从页缓存读取（若命中），无需访问磁盘，命中率高（大数据量场景下，热点消息多，页缓存利用率可达 80% 以上）；<br>日志分段与页缓存：每个 Segment 独立占用页缓存，避免大文件占用过多页缓存，提升缓存利用率；<br>关键配置：<br>log.flush.interval.messages=-1（默认）：禁用按消息数刷盘，依赖操作系统页缓存异步刷盘；<br>log.flush.interval.ms=-1（默认）：禁用按时间刷盘，由操作系统控制；<br>生产环境建议：保持默认配置，避免手动刷盘导致写入性能下降（若需强一致性，可启用 log.flush.interval.ms=1000，每 1 秒刷盘一次）。<br>（3）核心优化 3：零拷贝技术（Zero-Copy）（读取优化核心）<br>零拷贝定义：传统文件传输需要 4 次数据拷贝（磁盘→内核缓存→用户缓存→内核 socket 缓存→网络），零拷贝通过 sendfile() 系统调用，将数据直接从内核缓存传输到网络 socket，减少 2 次拷贝（用户态和内核态之间的拷贝）；<br>Kafka 的零拷贝实现：<br>使用场景：消费者拉取消息时，消息从磁盘文件（.log）传输到网络 socket；<br>实现方式：通过 FileChannel.transferTo() 方法（底层调用 sendfile()），将消息直接从文件传输到网络，无需经过用户态；<br>性能提升：零拷贝减少了 CPU 开销（减少数据拷贝）和内存带宽占用（减少内存拷贝），让 Kafka 单 Broker 读取吞吐量可达 200MB/s 以上。<br>（4）RocketMQ 的磁盘 IO 优化机制<br>RocketMQ 的磁盘 IO 优化与 Kafka 类似，但实现细节有差异：<br>顺序写磁盘：<br>CommitLog 顺序写：所有消息统一写入 CommitLog，顺序追加，充分利用顺序 IO 性能（类似 Kafka 的分区顺序写）；<br>文件滚动：CommitLog 按大小（默认 1GB）和时间（默认 72 小时）滚动，避免单个文件过大影响性能。<br>页缓存优化：<br>写入优化：消息先写入页缓存，由操作系统异步刷盘，减少磁盘 IO 阻塞（与 Kafka 相同）；<br>读取优化：ConsumeQueue 文件小（默认 600 万条消息，约 120MB），可全量加载到内存，读取性能极高；CommitLog 读取时优先从页缓存读取，命中率高。<br>零拷贝技术：<br>实现方式：RocketMQ 同样使用 sendfile() 系统调用实现零拷贝，消息从 CommitLog 传输到网络 socket 时无需经过用户态；<br>性能提升：零拷贝减少 CPU 开销和内存带宽占用，提升读取性能。<br>刷盘策略：<br>同步刷盘（SYNC_FLUSH）：消息写入后立即刷盘，保证数据不丢失，但性能较低（适合强一致性场景）；<br>异步刷盘（ASYNC_FLUSH）：消息写入页缓存后异步刷盘，性能高但可能丢失数据（适合高性能场景）。<br>与 Kafka 磁盘 IO 优化的对比：<br>| 对比维度 | Kafka | RocketMQ |<br>|———|——-|———-|<br>| 顺序写 | 分区独立顺序写 | CommitLog 统一顺序写 |<br>| 页缓存 | 利用操作系统页缓存 | 利用操作系统页缓存 + ConsumeQueue 全量加载内存 |<br>| 零拷贝 | sendfile() 系统调用 | sendfile() 系统调用 |<br>| 刷盘策略 | 异步刷盘（默认） | 同步/异步刷盘可选 |<br>| 文件组织 | 分区独立文件 | CommitLog 统一文件 + ConsumeQueue 独立文件 |<br>| 读取优化 | 按分区读取，稀疏索引 | 按 Queue 读取，ConsumeQueue 可全量加载内存 |</p><p>为什么会有这种差别？<br>存储架构不同：<br>Kafka：分区独立存储，每个分区独立顺序写，分区数多时文件数多，但分区隔离性好；<br>RocketMQ：统一存储架构，所有消息写入同一个 CommitLog，顺序写性能最优，但需要 ConsumeQueue 来支持按 Queue 消费。<br>索引优化不同：<br>Kafka：稀疏索引（.index），索引文件小，但查询时需要顺序扫描；<br>RocketMQ：ConsumeQueue 文件小可全量加载内存，查询性能更高，但存储开销略大。<br>刷盘策略不同：<br>Kafka：默认异步刷盘，追求高性能，通过 ISR 机制保证数据一致性；<br>RocketMQ：支持同步/异步刷盘可选，同步刷盘保证强一致性，异步刷盘追求高性能。<br>面试加分点：<br>提到 mmap（内存映射）：RocketMQ 的 ConsumeQueue 使用 mmap 内存映射，将文件映射到内存，提升读取性能（Kafka 的索引文件也使用 mmap）；<br>结合源码：Kafka 的零拷贝实现在 FileChannel.transferTo() 方法，RocketMQ 的零拷贝实现在 MappedFile 类的 transferTo() 方法；<br>生产环境建议：Kafka 保持默认异步刷盘配置，通过 ISR 机制保证数据一致性；RocketMQ 根据业务需求选择同步/异步刷盘，强一致性场景使用同步刷盘，高性能场景使用异步刷盘。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;题目：Kafka 的日志分段（Log Segmentation）机制是什么？如何影响读写性能和数据清理？&lt;br&gt;核心考点：日志存储底层设计、性能优化逻辑&lt;br&gt;详细答案：&lt;br&gt;Kafka 的日志分段是将 Topic 分区的日志文件（.log）按 “大小 + 时
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
